#ifdef TARGET_HAS_Protobuf

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Muse_v2.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Muse_v2.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace interaxon {
namespace muse_data {

void protobuf_ShutdownFile_Muse_5fv2_2eproto() {
  delete MuseDataCollection::default_instance_;
  delete MuseData::default_instance_;
  delete EEG::default_instance_;
  delete MuseQuantization::default_instance_;
  delete Accelerometer::default_instance_;
  delete Gyro::default_instance_;
  delete Annotation::default_instance_;
  delete Battery::default_instance_;
  delete MuseVersion::default_instance_;
  delete MuseConfig::default_instance_;
  delete EEG_DroppedSamples::default_instance_;
  delete ACC_DroppedSamples::default_instance_;
  delete ComputingDevice::default_instance_;
  delete DSP::default_instance_;
  delete MuseElement::default_instance_;
}

void protobuf_AddDesc_Muse_5fv2_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  MuseDataCollection::default_instance_ = new MuseDataCollection();
  MuseData::default_instance_ = new MuseData();
  EEG::default_instance_ = new EEG();
  MuseQuantization::default_instance_ = new MuseQuantization();
  Accelerometer::default_instance_ = new Accelerometer();
  Gyro::default_instance_ = new Gyro();
  Annotation::default_instance_ = new Annotation();
  Battery::default_instance_ = new Battery();
  MuseVersion::default_instance_ = new MuseVersion();
  MuseConfig::default_instance_ = new MuseConfig();
  EEG_DroppedSamples::default_instance_ = new EEG_DroppedSamples();
  ACC_DroppedSamples::default_instance_ = new ACC_DroppedSamples();
  ComputingDevice::default_instance_ = new ComputingDevice();
  DSP::default_instance_ = new DSP();
  MuseElement::default_instance_ = new MuseElement();
  MuseDataCollection::default_instance_->InitAsDefaultInstance();
  MuseData::default_instance_->InitAsDefaultInstance();
  EEG::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    8, 11, false, false,
    &::interaxon::muse_data::EEG::default_instance());
  MuseQuantization::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    9, 11, false, false,
    &::interaxon::muse_data::MuseQuantization::default_instance());
  Accelerometer::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    10, 11, false, false,
    &::interaxon::muse_data::Accelerometer::default_instance());
  Gyro::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    12, 11, false, false,
    &::interaxon::muse_data::Gyro::default_instance());
  Annotation::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    100, 11, false, false,
    &::interaxon::muse_data::Annotation::default_instance());
  Battery::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    101, 11, false, false,
    &::interaxon::muse_data::Battery::default_instance());
  MuseVersion::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    102, 11, false, false,
    &::interaxon::muse_data::MuseVersion::default_instance());
  MuseConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    103, 11, false, false,
    &::interaxon::muse_data::MuseConfig::default_instance());
  EEG_DroppedSamples::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    202, 11, false, false,
    &::interaxon::muse_data::EEG_DroppedSamples::default_instance());
  ACC_DroppedSamples::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    203, 11, false, false,
    &::interaxon::muse_data::ACC_DroppedSamples::default_instance());
  ComputingDevice::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    201, 11, false, false,
    &::interaxon::muse_data::ComputingDevice::default_instance());
  DSP::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    200, 11, false, false,
    &::interaxon::muse_data::DSP::default_instance());
  MuseElement::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::interaxon::muse_data::MuseData::default_instance(),
    204, 11, false, false,
    &::interaxon::muse_data::MuseElement::default_instance());
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Muse_5fv2_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Muse_5fv2_2eproto {
  StaticDescriptorInitializer_Muse_5fv2_2eproto() {
    protobuf_AddDesc_Muse_5fv2_2eproto();
  }
} static_descriptor_initializer_Muse_5fv2_2eproto_;
bool HeadLocations_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
      return true;
    default:
      return false;
  }
}

bool EEGUnits_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool AccelerometerUnits_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool MuseElementType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseDataCollection::kCollectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MuseDataCollection::MuseDataCollection()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseDataCollection)
}

void MuseDataCollection::InitAsDefaultInstance() {
}

MuseDataCollection::MuseDataCollection(const MuseDataCollection& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseDataCollection)
}

void MuseDataCollection::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseDataCollection::~MuseDataCollection() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseDataCollection)
  SharedDtor();
}

void MuseDataCollection::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseDataCollection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseDataCollection& MuseDataCollection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseDataCollection* MuseDataCollection::default_instance_ = NULL;

MuseDataCollection* MuseDataCollection::New(::google::protobuf::Arena* arena) const {
  MuseDataCollection* n = new MuseDataCollection;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseDataCollection::Clear() {
  collection_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseDataCollection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseDataCollection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .interaxon.muse_data.MuseData collection = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_collection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_collection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_collection;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseDataCollection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseDataCollection)
  return false;
#undef DO_
}

void MuseDataCollection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseDataCollection)
  // repeated .interaxon.muse_data.MuseData collection = 1;
  for (unsigned int i = 0, n = this->collection_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->collection(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseDataCollection)
}

int MuseDataCollection::ByteSize() const {
  int total_size = 0;

  // repeated .interaxon.muse_data.MuseData collection = 1;
  total_size += 1 * this->collection_size();
  for (int i = 0; i < this->collection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->collection(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseDataCollection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseDataCollection*>(&from));
}

void MuseDataCollection::MergeFrom(const MuseDataCollection& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  collection_.MergeFrom(from.collection_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseDataCollection::CopyFrom(const MuseDataCollection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseDataCollection::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->collection())) return false;
  return true;
}

void MuseDataCollection::Swap(MuseDataCollection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseDataCollection::InternalSwap(MuseDataCollection* other) {
  collection_.UnsafeArenaSwap(&other->collection_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MuseDataCollection::GetTypeName() const {
  return "interaxon.muse_data.MuseDataCollection";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseDataCollection

// repeated .interaxon.muse_data.MuseData collection = 1;
int MuseDataCollection::collection_size() const {
  return collection_.size();
}
void MuseDataCollection::clear_collection() {
  collection_.Clear();
}
const ::interaxon::muse_data::MuseData& MuseDataCollection::collection(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Get(index);
}
::interaxon::muse_data::MuseData* MuseDataCollection::mutable_collection(int index) {
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Mutable(index);
}
::interaxon::muse_data::MuseData* MuseDataCollection::add_collection() {
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Add();
}
::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >*
MuseDataCollection::mutable_collection() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseDataCollection.collection)
  return &collection_;
}
const ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >&
MuseDataCollection::collection() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseDataCollection.collection)
  return collection_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool MuseData_Datatype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MuseData_Datatype MuseData::EEG;
const MuseData_Datatype MuseData::QUANT;
const MuseData_Datatype MuseData::ACCEL;
const MuseData_Datatype MuseData::BATTERY;
const MuseData_Datatype MuseData::VERSION;
const MuseData_Datatype MuseData::CONFIG;
const MuseData_Datatype MuseData::ANNOTATION;
const MuseData_Datatype MuseData::HISTOGRAM;
const MuseData_Datatype MuseData::ALGVALUE;
const MuseData_Datatype MuseData::DSP;
const MuseData_Datatype MuseData::COMPUTING_DEVICE;
const MuseData_Datatype MuseData::EEG_DROPPED;
const MuseData_Datatype MuseData::ACC_DROPPED;
const MuseData_Datatype MuseData::CALM_APP;
const MuseData_Datatype MuseData::CALM_ALG;
const MuseData_Datatype MuseData::MUSE_ELEMENTS;
const MuseData_Datatype MuseData::GYRO;
const MuseData_Datatype MuseData::Datatype_MIN;
const MuseData_Datatype MuseData::Datatype_MAX;
const int MuseData::Datatype_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseData::kTimestampFieldNumber;
const int MuseData::kDatatypeFieldNumber;
const int MuseData::kConfigIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MuseData::MuseData()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseData)
}

void MuseData::InitAsDefaultInstance() {
}

MuseData::MuseData(const MuseData& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseData)
}

void MuseData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = 0;
  datatype_ = 0;
  config_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseData::~MuseData() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseData)
  SharedDtor();
}

void MuseData::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseData& MuseData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseData* MuseData::default_instance_ = NULL;

MuseData* MuseData::New(::google::protobuf::Arena* arena) const {
  MuseData* n = new MuseData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseData::Clear() {
  _extensions_.Clear();
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MuseData*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(timestamp_, datatype_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_datatype;
        break;
      }

      // required .interaxon.muse_data.MuseData.Datatype datatype = 2;
      case 2: {
        if (tag == 16) {
         parse_datatype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::MuseData_Datatype_IsValid(value)) {
            set_datatype(static_cast< ::interaxon::muse_data::MuseData_Datatype >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_config_id;
        break;
      }

      // optional uint64 config_id = 3;
      case 3: {
        if (tag == 24) {
         parse_config_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &config_id_)));
          set_has_config_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((64u <= tag && tag < 8000u) ||
            (8000u <= tag && tag < 16384u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      &unknown_fields_stream));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseData)
  return false;
#undef DO_
}

void MuseData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseData)
  // required double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }

  // required .interaxon.muse_data.MuseData.Datatype datatype = 2;
  if (has_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->datatype(), output);
  }

  // optional uint64 config_id = 3;
  if (has_config_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->config_id(), output);
  }

  // Extension range [8, 1000)
  _extensions_.SerializeWithCachedSizes(
      8, 1000, output);

  // Extension range [1000, 2048)
  _extensions_.SerializeWithCachedSizes(
      1000, 2048, output);

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseData)
}

int MuseData::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_timestamp()) {
    // required double timestamp = 1;
    total_size += 1 + 8;
  }

  if (has_datatype()) {
    // required .interaxon.muse_data.MuseData.Datatype datatype = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());
  }

  return total_size;
}
int MuseData::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double timestamp = 1;
    total_size += 1 + 8;

    // required .interaxon.muse_data.MuseData.Datatype datatype = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint64 config_id = 3;
  if (has_config_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->config_id());
  }

  total_size += _extensions_.ByteSize();

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseData*>(&from));
}

void MuseData::MergeFrom(const MuseData& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_datatype()) {
      set_datatype(from.datatype());
    }
    if (from.has_config_id()) {
      set_config_id(from.config_id());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseData::CopyFrom(const MuseData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;


  if (!_extensions_.IsInitialized()) return false;  return true;
}

void MuseData::Swap(MuseData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseData::InternalSwap(MuseData* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(datatype_, other->datatype_);
  std::swap(config_id_, other->config_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::std::string MuseData::GetTypeName() const {
  return "interaxon.muse_data.MuseData";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseData

// required double timestamp = 1;
bool MuseData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MuseData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void MuseData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void MuseData::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
 double MuseData::timestamp() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.timestamp)
  return timestamp_;
}
 void MuseData::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.timestamp)
}

// required .interaxon.muse_data.MuseData.Datatype datatype = 2;
bool MuseData::has_datatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MuseData::set_has_datatype() {
  _has_bits_[0] |= 0x00000002u;
}
void MuseData::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000002u;
}
void MuseData::clear_datatype() {
  datatype_ = 0;
  clear_has_datatype();
}
 ::interaxon::muse_data::MuseData_Datatype MuseData::datatype() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.datatype)
  return static_cast< ::interaxon::muse_data::MuseData_Datatype >(datatype_);
}
 void MuseData::set_datatype(::interaxon::muse_data::MuseData_Datatype value) {
  assert(::interaxon::muse_data::MuseData_Datatype_IsValid(value));
  set_has_datatype();
  datatype_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.datatype)
}

// optional uint64 config_id = 3;
bool MuseData::has_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MuseData::set_has_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
void MuseData::clear_has_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void MuseData::clear_config_id() {
  config_id_ = GOOGLE_ULONGLONG(0);
  clear_has_config_id();
}
 ::google::protobuf::uint64 MuseData::config_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.config_id)
  return config_id_;
}
 void MuseData::set_config_id(::google::protobuf::uint64 value) {
  set_has_config_id();
  config_id_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.config_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EEG::kValuesFieldNumber;
const int EEG::kDrlFieldNumber;
const int EEG::kRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EEG::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::EEG >, 11, false >
  EEG::museData(kMuseDataFieldNumber, ::interaxon::muse_data::EEG::default_instance());
EEG::EEG()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.EEG)
}

void EEG::InitAsDefaultInstance() {
}

EEG::EEG(const EEG& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.EEG)
}

void EEG::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  drl_ = 0;
  ref_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EEG::~EEG() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.EEG)
  SharedDtor();
}

void EEG::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void EEG::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EEG& EEG::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

EEG* EEG::default_instance_ = NULL;

EEG* EEG::New(::google::protobuf::Arena* arena) const {
  EEG* n = new EEG;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EEG::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<EEG*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(drl_, ref_);

#undef ZR_HELPER_
#undef ZR_

  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EEG::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.EEG)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float values = 2;
      case 2: {
        if (tag == 21) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_values())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_values;
        if (input->ExpectTag(45)) goto parse_drl;
        break;
      }

      // optional float drl = 5;
      case 5: {
        if (tag == 45) {
         parse_drl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &drl_)));
          set_has_drl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_ref;
        break;
      }

      // optional float ref = 6;
      case 6: {
        if (tag == 53) {
         parse_ref:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ref_)));
          set_has_ref();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.EEG)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.EEG)
  return false;
#undef DO_
}

void EEG::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.EEG)
  // repeated float values = 2;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->values(i), output);
  }

  // optional float drl = 5;
  if (has_drl()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->drl(), output);
  }

  // optional float ref = 6;
  if (has_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->ref(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.EEG)
}

int EEG::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & 6u) {
    // optional float drl = 5;
    if (has_drl()) {
      total_size += 1 + 4;
    }

    // optional float ref = 6;
    if (has_ref()) {
      total_size += 1 + 4;
    }

  }
  // repeated float values = 2;
  {
    int data_size = 0;
    data_size = 4 * this->values_size();
    total_size += 1 * this->values_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EEG::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EEG*>(&from));
}

void EEG::MergeFrom(const EEG& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  values_.MergeFrom(from.values_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_drl()) {
      set_drl(from.drl());
    }
    if (from.has_ref()) {
      set_ref(from.ref());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EEG::CopyFrom(const EEG& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EEG::IsInitialized() const {

  return true;
}

void EEG::Swap(EEG* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EEG::InternalSwap(EEG* other) {
  values_.UnsafeArenaSwap(&other->values_);
  std::swap(drl_, other->drl_);
  std::swap(ref_, other->ref_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EEG::GetTypeName() const {
  return "interaxon.muse_data.EEG";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EEG

// repeated float values = 2;
int EEG::values_size() const {
  return values_.size();
}
void EEG::clear_values() {
  values_.Clear();
}
 float EEG::values(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.values)
  return values_.Get(index);
}
 void EEG::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.values)
}
 void EEG::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.EEG.values)
}
 const ::google::protobuf::RepeatedField< float >&
EEG::values() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.EEG.values)
  return values_;
}
 ::google::protobuf::RepeatedField< float >*
EEG::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.EEG.values)
  return &values_;
}

// optional float drl = 5;
bool EEG::has_drl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EEG::set_has_drl() {
  _has_bits_[0] |= 0x00000002u;
}
void EEG::clear_has_drl() {
  _has_bits_[0] &= ~0x00000002u;
}
void EEG::clear_drl() {
  drl_ = 0;
  clear_has_drl();
}
 float EEG::drl() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.drl)
  return drl_;
}
 void EEG::set_drl(float value) {
  set_has_drl();
  drl_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.drl)
}

// optional float ref = 6;
bool EEG::has_ref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EEG::set_has_ref() {
  _has_bits_[0] |= 0x00000004u;
}
void EEG::clear_has_ref() {
  _has_bits_[0] &= ~0x00000004u;
}
void EEG::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
 float EEG::ref() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.ref)
  return ref_;
}
 void EEG::set_ref(float value) {
  set_has_ref();
  ref_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.ref)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseQuantization::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseQuantization::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseQuantization >, 11, false >
  MuseQuantization::museData(kMuseDataFieldNumber, ::interaxon::muse_data::MuseQuantization::default_instance());
MuseQuantization::MuseQuantization()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseQuantization)
}

void MuseQuantization::InitAsDefaultInstance() {
}

MuseQuantization::MuseQuantization(const MuseQuantization& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseQuantization)
}

void MuseQuantization::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseQuantization::~MuseQuantization() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseQuantization)
  SharedDtor();
}

void MuseQuantization::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseQuantization::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseQuantization& MuseQuantization::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseQuantization* MuseQuantization::default_instance_ = NULL;

MuseQuantization* MuseQuantization::New(::google::protobuf::Arena* arena) const {
  MuseQuantization* n = new MuseQuantization;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseQuantization::Clear() {
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseQuantization::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseQuantization)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 values = 1;
      case 1: {
        if (tag == 8) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_values())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseQuantization)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseQuantization)
  return false;
#undef DO_
}

void MuseQuantization::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseQuantization)
  // repeated uint32 values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->values(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseQuantization)
}

int MuseQuantization::ByteSize() const {
  int total_size = 0;

  // repeated uint32 values = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->values_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->values(i));
    }
    total_size += 1 * this->values_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseQuantization::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseQuantization*>(&from));
}

void MuseQuantization::MergeFrom(const MuseQuantization& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  values_.MergeFrom(from.values_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseQuantization::CopyFrom(const MuseQuantization& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseQuantization::IsInitialized() const {

  return true;
}

void MuseQuantization::Swap(MuseQuantization* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseQuantization::InternalSwap(MuseQuantization* other) {
  values_.UnsafeArenaSwap(&other->values_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MuseQuantization::GetTypeName() const {
  return "interaxon.muse_data.MuseQuantization";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseQuantization

// repeated uint32 values = 1;
int MuseQuantization::values_size() const {
  return values_.size();
}
void MuseQuantization::clear_values() {
  values_.Clear();
}
 ::google::protobuf::uint32 MuseQuantization::values(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseQuantization.values)
  return values_.Get(index);
}
 void MuseQuantization::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseQuantization.values)
}
 void MuseQuantization::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseQuantization.values)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MuseQuantization::values() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseQuantization.values)
  return values_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MuseQuantization::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseQuantization.values)
  return &values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Accelerometer::kAcc1FieldNumber;
const int Accelerometer::kAcc2FieldNumber;
const int Accelerometer::kAcc3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Accelerometer::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Accelerometer >, 11, false >
  Accelerometer::museData(kMuseDataFieldNumber, ::interaxon::muse_data::Accelerometer::default_instance());
Accelerometer::Accelerometer()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.Accelerometer)
}

void Accelerometer::InitAsDefaultInstance() {
}

Accelerometer::Accelerometer(const Accelerometer& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.Accelerometer)
}

void Accelerometer::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  acc1_ = 0;
  acc2_ = 0;
  acc3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Accelerometer::~Accelerometer() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.Accelerometer)
  SharedDtor();
}

void Accelerometer::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Accelerometer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Accelerometer& Accelerometer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

Accelerometer* Accelerometer::default_instance_ = NULL;

Accelerometer* Accelerometer::New(::google::protobuf::Arena* arena) const {
  Accelerometer* n = new Accelerometer;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Accelerometer::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Accelerometer*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(acc1_, acc3_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Accelerometer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.Accelerometer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float acc1 = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc1_)));
          set_has_acc1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_acc2;
        break;
      }

      // optional float acc2 = 2;
      case 2: {
        if (tag == 21) {
         parse_acc2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc2_)));
          set_has_acc2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_acc3;
        break;
      }

      // optional float acc3 = 3;
      case 3: {
        if (tag == 29) {
         parse_acc3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc3_)));
          set_has_acc3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.Accelerometer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.Accelerometer)
  return false;
#undef DO_
}

void Accelerometer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.Accelerometer)
  // optional float acc1 = 1;
  if (has_acc1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->acc1(), output);
  }

  // optional float acc2 = 2;
  if (has_acc2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->acc2(), output);
  }

  // optional float acc3 = 3;
  if (has_acc3()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->acc3(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.Accelerometer)
}

int Accelerometer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional float acc1 = 1;
    if (has_acc1()) {
      total_size += 1 + 4;
    }

    // optional float acc2 = 2;
    if (has_acc2()) {
      total_size += 1 + 4;
    }

    // optional float acc3 = 3;
    if (has_acc3()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Accelerometer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Accelerometer*>(&from));
}

void Accelerometer::MergeFrom(const Accelerometer& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc1()) {
      set_acc1(from.acc1());
    }
    if (from.has_acc2()) {
      set_acc2(from.acc2());
    }
    if (from.has_acc3()) {
      set_acc3(from.acc3());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Accelerometer::CopyFrom(const Accelerometer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Accelerometer::IsInitialized() const {

  return true;
}

void Accelerometer::Swap(Accelerometer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Accelerometer::InternalSwap(Accelerometer* other) {
  std::swap(acc1_, other->acc1_);
  std::swap(acc2_, other->acc2_);
  std::swap(acc3_, other->acc3_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Accelerometer::GetTypeName() const {
  return "interaxon.muse_data.Accelerometer";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Accelerometer

// optional float acc1 = 1;
bool Accelerometer::has_acc1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Accelerometer::set_has_acc1() {
  _has_bits_[0] |= 0x00000001u;
}
void Accelerometer::clear_has_acc1() {
  _has_bits_[0] &= ~0x00000001u;
}
void Accelerometer::clear_acc1() {
  acc1_ = 0;
  clear_has_acc1();
}
 float Accelerometer::acc1() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc1)
  return acc1_;
}
 void Accelerometer::set_acc1(float value) {
  set_has_acc1();
  acc1_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc1)
}

// optional float acc2 = 2;
bool Accelerometer::has_acc2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Accelerometer::set_has_acc2() {
  _has_bits_[0] |= 0x00000002u;
}
void Accelerometer::clear_has_acc2() {
  _has_bits_[0] &= ~0x00000002u;
}
void Accelerometer::clear_acc2() {
  acc2_ = 0;
  clear_has_acc2();
}
 float Accelerometer::acc2() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc2)
  return acc2_;
}
 void Accelerometer::set_acc2(float value) {
  set_has_acc2();
  acc2_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc2)
}

// optional float acc3 = 3;
bool Accelerometer::has_acc3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Accelerometer::set_has_acc3() {
  _has_bits_[0] |= 0x00000004u;
}
void Accelerometer::clear_has_acc3() {
  _has_bits_[0] &= ~0x00000004u;
}
void Accelerometer::clear_acc3() {
  acc3_ = 0;
  clear_has_acc3();
}
 float Accelerometer::acc3() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc3)
  return acc3_;
}
 void Accelerometer::set_acc3(float value) {
  set_has_acc3();
  acc3_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc3)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Gyro::kGyro1FieldNumber;
const int Gyro::kGyro2FieldNumber;
const int Gyro::kGyro3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Gyro::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Gyro >, 11, false >
  Gyro::museData(kMuseDataFieldNumber, ::interaxon::muse_data::Gyro::default_instance());
Gyro::Gyro()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.Gyro)
}

void Gyro::InitAsDefaultInstance() {
}

Gyro::Gyro(const Gyro& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.Gyro)
}

void Gyro::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gyro1_ = 0;
  gyro2_ = 0;
  gyro3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Gyro::~Gyro() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.Gyro)
  SharedDtor();
}

void Gyro::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Gyro::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Gyro& Gyro::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

Gyro* Gyro::default_instance_ = NULL;

Gyro* Gyro::New(::google::protobuf::Arena* arena) const {
  Gyro* n = new Gyro;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Gyro::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Gyro*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(gyro1_, gyro3_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Gyro::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.Gyro)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float gyro1 = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro1_)));
          set_has_gyro1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_gyro2;
        break;
      }

      // optional float gyro2 = 2;
      case 2: {
        if (tag == 21) {
         parse_gyro2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro2_)));
          set_has_gyro2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_gyro3;
        break;
      }

      // optional float gyro3 = 3;
      case 3: {
        if (tag == 29) {
         parse_gyro3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro3_)));
          set_has_gyro3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.Gyro)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.Gyro)
  return false;
#undef DO_
}

void Gyro::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.Gyro)
  // optional float gyro1 = 1;
  if (has_gyro1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->gyro1(), output);
  }

  // optional float gyro2 = 2;
  if (has_gyro2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->gyro2(), output);
  }

  // optional float gyro3 = 3;
  if (has_gyro3()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->gyro3(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.Gyro)
}

int Gyro::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional float gyro1 = 1;
    if (has_gyro1()) {
      total_size += 1 + 4;
    }

    // optional float gyro2 = 2;
    if (has_gyro2()) {
      total_size += 1 + 4;
    }

    // optional float gyro3 = 3;
    if (has_gyro3()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Gyro::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Gyro*>(&from));
}

void Gyro::MergeFrom(const Gyro& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gyro1()) {
      set_gyro1(from.gyro1());
    }
    if (from.has_gyro2()) {
      set_gyro2(from.gyro2());
    }
    if (from.has_gyro3()) {
      set_gyro3(from.gyro3());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Gyro::CopyFrom(const Gyro& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gyro::IsInitialized() const {

  return true;
}

void Gyro::Swap(Gyro* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Gyro::InternalSwap(Gyro* other) {
  std::swap(gyro1_, other->gyro1_);
  std::swap(gyro2_, other->gyro2_);
  std::swap(gyro3_, other->gyro3_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Gyro::GetTypeName() const {
  return "interaxon.muse_data.Gyro";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Gyro

// optional float gyro1 = 1;
bool Gyro::has_gyro1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Gyro::set_has_gyro1() {
  _has_bits_[0] |= 0x00000001u;
}
void Gyro::clear_has_gyro1() {
  _has_bits_[0] &= ~0x00000001u;
}
void Gyro::clear_gyro1() {
  gyro1_ = 0;
  clear_has_gyro1();
}
 float Gyro::gyro1() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro1)
  return gyro1_;
}
 void Gyro::set_gyro1(float value) {
  set_has_gyro1();
  gyro1_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro1)
}

// optional float gyro2 = 2;
bool Gyro::has_gyro2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Gyro::set_has_gyro2() {
  _has_bits_[0] |= 0x00000002u;
}
void Gyro::clear_has_gyro2() {
  _has_bits_[0] &= ~0x00000002u;
}
void Gyro::clear_gyro2() {
  gyro2_ = 0;
  clear_has_gyro2();
}
 float Gyro::gyro2() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro2)
  return gyro2_;
}
 void Gyro::set_gyro2(float value) {
  set_has_gyro2();
  gyro2_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro2)
}

// optional float gyro3 = 3;
bool Gyro::has_gyro3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Gyro::set_has_gyro3() {
  _has_bits_[0] |= 0x00000004u;
}
void Gyro::clear_has_gyro3() {
  _has_bits_[0] &= ~0x00000004u;
}
void Gyro::clear_gyro3() {
  gyro3_ = 0;
  clear_has_gyro3();
}
 float Gyro::gyro3() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro3)
  return gyro3_;
}
 void Gyro::set_gyro3(float value) {
  set_has_gyro3();
  gyro3_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro3)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool Annotation_Format_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Annotation_Format Annotation::PLAIN_STRING;
const Annotation_Format Annotation::JSON;
const Annotation_Format Annotation::OSC;
const Annotation_Format Annotation::Format_MIN;
const Annotation_Format Annotation::Format_MAX;
const int Annotation::Format_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Annotation::kEventDataFieldNumber;
const int Annotation::kEventDataFormatFieldNumber;
const int Annotation::kEventTypeFieldNumber;
const int Annotation::kEventIdFieldNumber;
const int Annotation::kParentIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Annotation::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Annotation >, 11, false >
  Annotation::museData(kMuseDataFieldNumber, ::interaxon::muse_data::Annotation::default_instance());
Annotation::Annotation()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.Annotation)
}

void Annotation::InitAsDefaultInstance() {
}

Annotation::Annotation(const Annotation& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.Annotation)
}

void Annotation::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_data_format_ = 0;
  event_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Annotation::~Annotation() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.Annotation)
  SharedDtor();
}

void Annotation::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  event_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Annotation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Annotation& Annotation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

Annotation* Annotation::default_instance_ = NULL;

Annotation* Annotation::New(::google::protobuf::Arena* arena) const {
  Annotation* n = new Annotation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Annotation::Clear() {
  if (_has_bits_[0 / 32] & 31u) {
    if (has_event_data()) {
      event_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    event_data_format_ = 0;
    if (has_event_type()) {
      event_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_event_id()) {
      event_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_parent_id()) {
      parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Annotation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.Annotation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string event_data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_event_data_format;
        break;
      }

      // optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
      case 2: {
        if (tag == 16) {
         parse_event_data_format:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::Annotation_Format_IsValid(value)) {
            set_event_data_format(static_cast< ::interaxon::muse_data::Annotation_Format >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_event_type;
        break;
      }

      // optional string event_type = 3;
      case 3: {
        if (tag == 26) {
         parse_event_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_event_id;
        break;
      }

      // optional string event_id = 4;
      case 4: {
        if (tag == 34) {
         parse_event_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_parent_id;
        break;
      }

      // optional string parent_id = 5;
      case 5: {
        if (tag == 42) {
         parse_parent_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_parent_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.Annotation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.Annotation)
  return false;
#undef DO_
}

void Annotation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.Annotation)
  // optional string event_data = 1;
  if (has_event_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->event_data(), output);
  }

  // optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
  if (has_event_data_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->event_data_format(), output);
  }

  // optional string event_type = 3;
  if (has_event_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->event_type(), output);
  }

  // optional string event_id = 4;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->event_id(), output);
  }

  // optional string parent_id = 5;
  if (has_parent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->parent_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.Annotation)
}

int Annotation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional string event_data = 1;
    if (has_event_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_data());
    }

    // optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
    if (has_event_data_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->event_data_format());
    }

    // optional string event_type = 3;
    if (has_event_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_type());
    }

    // optional string event_id = 4;
    if (has_event_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_id());
    }

    // optional string parent_id = 5;
    if (has_parent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->parent_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Annotation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Annotation*>(&from));
}

void Annotation::MergeFrom(const Annotation& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_event_data()) {
      set_has_event_data();
      event_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.event_data_);
    }
    if (from.has_event_data_format()) {
      set_event_data_format(from.event_data_format());
    }
    if (from.has_event_type()) {
      set_has_event_type();
      event_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.event_type_);
    }
    if (from.has_event_id()) {
      set_has_event_id();
      event_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.event_id_);
    }
    if (from.has_parent_id()) {
      set_has_parent_id();
      parent_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.parent_id_);
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Annotation::CopyFrom(const Annotation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Annotation::IsInitialized() const {

  return true;
}

void Annotation::Swap(Annotation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Annotation::InternalSwap(Annotation* other) {
  event_data_.Swap(&other->event_data_);
  std::swap(event_data_format_, other->event_data_format_);
  event_type_.Swap(&other->event_type_);
  event_id_.Swap(&other->event_id_);
  parent_id_.Swap(&other->parent_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Annotation::GetTypeName() const {
  return "interaxon.muse_data.Annotation";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Annotation

// optional string event_data = 1;
bool Annotation::has_event_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Annotation::set_has_event_data() {
  _has_bits_[0] |= 0x00000001u;
}
void Annotation::clear_has_event_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void Annotation::clear_event_data() {
  event_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_data();
}
 const ::std::string& Annotation::event_data() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_data)
  return event_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_event_data(const ::std::string& value) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_data)
}
 void Annotation::set_event_data(const char* value) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_data)
}
 void Annotation::set_event_data(const char* value, size_t size) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_data)
}
 ::std::string* Annotation::mutable_event_data() {
  set_has_event_data();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_data)
  return event_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Annotation::release_event_data() {
  clear_has_event_data();
  return event_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_allocated_event_data(::std::string* event_data) {
  if (event_data != NULL) {
    set_has_event_data();
  } else {
    clear_has_event_data();
  }
  event_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_data);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_data)
}

// optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
bool Annotation::has_event_data_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Annotation::set_has_event_data_format() {
  _has_bits_[0] |= 0x00000002u;
}
void Annotation::clear_has_event_data_format() {
  _has_bits_[0] &= ~0x00000002u;
}
void Annotation::clear_event_data_format() {
  event_data_format_ = 0;
  clear_has_event_data_format();
}
 ::interaxon::muse_data::Annotation_Format Annotation::event_data_format() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_data_format)
  return static_cast< ::interaxon::muse_data::Annotation_Format >(event_data_format_);
}
 void Annotation::set_event_data_format(::interaxon::muse_data::Annotation_Format value) {
  assert(::interaxon::muse_data::Annotation_Format_IsValid(value));
  set_has_event_data_format();
  event_data_format_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_data_format)
}

// optional string event_type = 3;
bool Annotation::has_event_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Annotation::set_has_event_type() {
  _has_bits_[0] |= 0x00000004u;
}
void Annotation::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void Annotation::clear_event_type() {
  event_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_type();
}
 const ::std::string& Annotation::event_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_type)
  return event_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_event_type(const ::std::string& value) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_type)
}
 void Annotation::set_event_type(const char* value) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_type)
}
 void Annotation::set_event_type(const char* value, size_t size) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_type)
}
 ::std::string* Annotation::mutable_event_type() {
  set_has_event_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_type)
  return event_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Annotation::release_event_type() {
  clear_has_event_type();
  return event_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_allocated_event_type(::std::string* event_type) {
  if (event_type != NULL) {
    set_has_event_type();
  } else {
    clear_has_event_type();
  }
  event_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_type)
}

// optional string event_id = 4;
bool Annotation::has_event_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Annotation::set_has_event_id() {
  _has_bits_[0] |= 0x00000008u;
}
void Annotation::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void Annotation::clear_event_id() {
  event_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_id();
}
 const ::std::string& Annotation::event_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_id)
  return event_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_event_id(const ::std::string& value) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_id)
}
 void Annotation::set_event_id(const char* value) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_id)
}
 void Annotation::set_event_id(const char* value, size_t size) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_id)
}
 ::std::string* Annotation::mutable_event_id() {
  set_has_event_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_id)
  return event_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Annotation::release_event_id() {
  clear_has_event_id();
  return event_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_allocated_event_id(::std::string* event_id) {
  if (event_id != NULL) {
    set_has_event_id();
  } else {
    clear_has_event_id();
  }
  event_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_id)
}

// optional string parent_id = 5;
bool Annotation::has_parent_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Annotation::set_has_parent_id() {
  _has_bits_[0] |= 0x00000010u;
}
void Annotation::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void Annotation::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_id();
}
 const ::std::string& Annotation::parent_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.parent_id)
  return parent_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_parent_id(const ::std::string& value) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.parent_id)
}
 void Annotation::set_parent_id(const char* value) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.parent_id)
}
 void Annotation::set_parent_id(const char* value, size_t size) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.parent_id)
}
 ::std::string* Annotation::mutable_parent_id() {
  set_has_parent_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Annotation::release_parent_id() {
  clear_has_parent_id();
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Annotation::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    set_has_parent_id();
  } else {
    clear_has_parent_id();
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.parent_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Battery::kPercentRemainingFieldNumber;
const int Battery::kBatteryFuelGaugeMillivoltsFieldNumber;
const int Battery::kBatteryAdcMillivoltsFieldNumber;
const int Battery::kTemperatureCelsiusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Battery::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Battery >, 11, false >
  Battery::museData(kMuseDataFieldNumber, ::interaxon::muse_data::Battery::default_instance());
Battery::Battery()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.Battery)
}

void Battery::InitAsDefaultInstance() {
}

Battery::Battery(const Battery& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.Battery)
}

void Battery::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  percent_remaining_ = 0u;
  battery_fuel_gauge_millivolts_ = 0u;
  battery_adc_millivolts_ = 0u;
  temperature_celsius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Battery::~Battery() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.Battery)
  SharedDtor();
}

void Battery::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Battery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Battery& Battery::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

Battery* Battery::default_instance_ = NULL;

Battery* Battery::New(::google::protobuf::Arena* arena) const {
  Battery* n = new Battery;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Battery::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Battery*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(percent_remaining_, temperature_celsius_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Battery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.Battery)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 percent_remaining = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &percent_remaining_)));
          set_has_percent_remaining();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_battery_fuel_gauge_millivolts;
        break;
      }

      // optional uint32 battery_fuel_gauge_millivolts = 2;
      case 2: {
        if (tag == 16) {
         parse_battery_fuel_gauge_millivolts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battery_fuel_gauge_millivolts_)));
          set_has_battery_fuel_gauge_millivolts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_battery_adc_millivolts;
        break;
      }

      // optional uint32 battery_adc_millivolts = 3;
      case 3: {
        if (tag == 24) {
         parse_battery_adc_millivolts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battery_adc_millivolts_)));
          set_has_battery_adc_millivolts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_temperature_celsius;
        break;
      }

      // optional sint32 temperature_celsius = 4;
      case 4: {
        if (tag == 32) {
         parse_temperature_celsius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &temperature_celsius_)));
          set_has_temperature_celsius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.Battery)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.Battery)
  return false;
#undef DO_
}

void Battery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.Battery)
  // optional uint32 percent_remaining = 1;
  if (has_percent_remaining()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->percent_remaining(), output);
  }

  // optional uint32 battery_fuel_gauge_millivolts = 2;
  if (has_battery_fuel_gauge_millivolts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->battery_fuel_gauge_millivolts(), output);
  }

  // optional uint32 battery_adc_millivolts = 3;
  if (has_battery_adc_millivolts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->battery_adc_millivolts(), output);
  }

  // optional sint32 temperature_celsius = 4;
  if (has_temperature_celsius()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->temperature_celsius(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.Battery)
}

int Battery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional uint32 percent_remaining = 1;
    if (has_percent_remaining()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->percent_remaining());
    }

    // optional uint32 battery_fuel_gauge_millivolts = 2;
    if (has_battery_fuel_gauge_millivolts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battery_fuel_gauge_millivolts());
    }

    // optional uint32 battery_adc_millivolts = 3;
    if (has_battery_adc_millivolts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battery_adc_millivolts());
    }

    // optional sint32 temperature_celsius = 4;
    if (has_temperature_celsius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->temperature_celsius());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Battery::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Battery*>(&from));
}

void Battery::MergeFrom(const Battery& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_percent_remaining()) {
      set_percent_remaining(from.percent_remaining());
    }
    if (from.has_battery_fuel_gauge_millivolts()) {
      set_battery_fuel_gauge_millivolts(from.battery_fuel_gauge_millivolts());
    }
    if (from.has_battery_adc_millivolts()) {
      set_battery_adc_millivolts(from.battery_adc_millivolts());
    }
    if (from.has_temperature_celsius()) {
      set_temperature_celsius(from.temperature_celsius());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Battery::CopyFrom(const Battery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Battery::IsInitialized() const {

  return true;
}

void Battery::Swap(Battery* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Battery::InternalSwap(Battery* other) {
  std::swap(percent_remaining_, other->percent_remaining_);
  std::swap(battery_fuel_gauge_millivolts_, other->battery_fuel_gauge_millivolts_);
  std::swap(battery_adc_millivolts_, other->battery_adc_millivolts_);
  std::swap(temperature_celsius_, other->temperature_celsius_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Battery::GetTypeName() const {
  return "interaxon.muse_data.Battery";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Battery

// optional uint32 percent_remaining = 1;
bool Battery::has_percent_remaining() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Battery::set_has_percent_remaining() {
  _has_bits_[0] |= 0x00000001u;
}
void Battery::clear_has_percent_remaining() {
  _has_bits_[0] &= ~0x00000001u;
}
void Battery::clear_percent_remaining() {
  percent_remaining_ = 0u;
  clear_has_percent_remaining();
}
 ::google::protobuf::uint32 Battery::percent_remaining() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.percent_remaining)
  return percent_remaining_;
}
 void Battery::set_percent_remaining(::google::protobuf::uint32 value) {
  set_has_percent_remaining();
  percent_remaining_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.percent_remaining)
}

// optional uint32 battery_fuel_gauge_millivolts = 2;
bool Battery::has_battery_fuel_gauge_millivolts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Battery::set_has_battery_fuel_gauge_millivolts() {
  _has_bits_[0] |= 0x00000002u;
}
void Battery::clear_has_battery_fuel_gauge_millivolts() {
  _has_bits_[0] &= ~0x00000002u;
}
void Battery::clear_battery_fuel_gauge_millivolts() {
  battery_fuel_gauge_millivolts_ = 0u;
  clear_has_battery_fuel_gauge_millivolts();
}
 ::google::protobuf::uint32 Battery::battery_fuel_gauge_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.battery_fuel_gauge_millivolts)
  return battery_fuel_gauge_millivolts_;
}
 void Battery::set_battery_fuel_gauge_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_fuel_gauge_millivolts();
  battery_fuel_gauge_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.battery_fuel_gauge_millivolts)
}

// optional uint32 battery_adc_millivolts = 3;
bool Battery::has_battery_adc_millivolts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Battery::set_has_battery_adc_millivolts() {
  _has_bits_[0] |= 0x00000004u;
}
void Battery::clear_has_battery_adc_millivolts() {
  _has_bits_[0] &= ~0x00000004u;
}
void Battery::clear_battery_adc_millivolts() {
  battery_adc_millivolts_ = 0u;
  clear_has_battery_adc_millivolts();
}
 ::google::protobuf::uint32 Battery::battery_adc_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.battery_adc_millivolts)
  return battery_adc_millivolts_;
}
 void Battery::set_battery_adc_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_adc_millivolts();
  battery_adc_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.battery_adc_millivolts)
}

// optional sint32 temperature_celsius = 4;
bool Battery::has_temperature_celsius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Battery::set_has_temperature_celsius() {
  _has_bits_[0] |= 0x00000008u;
}
void Battery::clear_has_temperature_celsius() {
  _has_bits_[0] &= ~0x00000008u;
}
void Battery::clear_temperature_celsius() {
  temperature_celsius_ = 0;
  clear_has_temperature_celsius();
}
 ::google::protobuf::int32 Battery::temperature_celsius() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.temperature_celsius)
  return temperature_celsius_;
}
 void Battery::set_temperature_celsius(::google::protobuf::int32 value) {
  set_has_temperature_celsius();
  temperature_celsius_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.temperature_celsius)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseVersion::kHardwareVersionFieldNumber;
const int MuseVersion::kFirmwareHeadsetVersionFieldNumber;
const int MuseVersion::kFirmwareTypeFieldNumber;
const int MuseVersion::kFirmwareBootloaderVersionFieldNumber;
const int MuseVersion::kBuildNumberFieldNumber;
const int MuseVersion::kProtocolVersionFieldNumber;
const int MuseVersion::kBspVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseVersion::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseVersion >, 11, false >
  MuseVersion::museData(kMuseDataFieldNumber, ::interaxon::muse_data::MuseVersion::default_instance());
MuseVersion::MuseVersion()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseVersion)
}

void MuseVersion::InitAsDefaultInstance() {
}

MuseVersion::MuseVersion(const MuseVersion& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseVersion)
}

void MuseVersion::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_headset_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_bootloader_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_number_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bsp_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseVersion::~MuseVersion() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseVersion)
  SharedDtor();
}

void MuseVersion::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_headset_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_bootloader_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_number_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bsp_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseVersion& MuseVersion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseVersion* MuseVersion::default_instance_ = NULL;

MuseVersion* MuseVersion::New(::google::protobuf::Arena* arena) const {
  MuseVersion* n = new MuseVersion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseVersion::Clear() {
  if (_has_bits_[0 / 32] & 127u) {
    if (has_hardware_version()) {
      hardware_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_firmware_headset_version()) {
      firmware_headset_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_firmware_type()) {
      firmware_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_firmware_bootloader_version()) {
      firmware_bootloader_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_build_number()) {
      build_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_protocol_version()) {
      protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_bsp_version()) {
      bsp_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseVersion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string hardware_version = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_firmware_headset_version;
        break;
      }

      // optional string firmware_headset_version = 2;
      case 2: {
        if (tag == 18) {
         parse_firmware_headset_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_headset_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_firmware_type;
        break;
      }

      // optional string firmware_type = 3;
      case 3: {
        if (tag == 26) {
         parse_firmware_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_firmware_bootloader_version;
        break;
      }

      // optional string firmware_bootloader_version = 4;
      case 4: {
        if (tag == 34) {
         parse_firmware_bootloader_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_bootloader_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_build_number;
        break;
      }

      // optional string build_number = 5;
      case 5: {
        if (tag == 42) {
         parse_build_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_number()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_protocol_version;
        break;
      }

      // optional string protocol_version = 6;
      case 6: {
        if (tag == 50) {
         parse_protocol_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_bsp_version;
        break;
      }

      // optional string bsp_version = 7;
      case 7: {
        if (tag == 58) {
         parse_bsp_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bsp_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseVersion)
  return false;
#undef DO_
}

void MuseVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseVersion)
  // optional string hardware_version = 1;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hardware_version(), output);
  }

  // optional string firmware_headset_version = 2;
  if (has_firmware_headset_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->firmware_headset_version(), output);
  }

  // optional string firmware_type = 3;
  if (has_firmware_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->firmware_type(), output);
  }

  // optional string firmware_bootloader_version = 4;
  if (has_firmware_bootloader_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->firmware_bootloader_version(), output);
  }

  // optional string build_number = 5;
  if (has_build_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->build_number(), output);
  }

  // optional string protocol_version = 6;
  if (has_protocol_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->protocol_version(), output);
  }

  // optional string bsp_version = 7;
  if (has_bsp_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->bsp_version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseVersion)
}

int MuseVersion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional string hardware_version = 1;
    if (has_hardware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_version());
    }

    // optional string firmware_headset_version = 2;
    if (has_firmware_headset_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmware_headset_version());
    }

    // optional string firmware_type = 3;
    if (has_firmware_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmware_type());
    }

    // optional string firmware_bootloader_version = 4;
    if (has_firmware_bootloader_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmware_bootloader_version());
    }

    // optional string build_number = 5;
    if (has_build_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_number());
    }

    // optional string protocol_version = 6;
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->protocol_version());
    }

    // optional string bsp_version = 7;
    if (has_bsp_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bsp_version());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseVersion::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseVersion*>(&from));
}

void MuseVersion::MergeFrom(const MuseVersion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hardware_version()) {
      set_has_hardware_version();
      hardware_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hardware_version_);
    }
    if (from.has_firmware_headset_version()) {
      set_has_firmware_headset_version();
      firmware_headset_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firmware_headset_version_);
    }
    if (from.has_firmware_type()) {
      set_has_firmware_type();
      firmware_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firmware_type_);
    }
    if (from.has_firmware_bootloader_version()) {
      set_has_firmware_bootloader_version();
      firmware_bootloader_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firmware_bootloader_version_);
    }
    if (from.has_build_number()) {
      set_has_build_number();
      build_number_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.build_number_);
    }
    if (from.has_protocol_version()) {
      set_has_protocol_version();
      protocol_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.protocol_version_);
    }
    if (from.has_bsp_version()) {
      set_has_bsp_version();
      bsp_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bsp_version_);
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseVersion::CopyFrom(const MuseVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseVersion::IsInitialized() const {

  return true;
}

void MuseVersion::Swap(MuseVersion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseVersion::InternalSwap(MuseVersion* other) {
  hardware_version_.Swap(&other->hardware_version_);
  firmware_headset_version_.Swap(&other->firmware_headset_version_);
  firmware_type_.Swap(&other->firmware_type_);
  firmware_bootloader_version_.Swap(&other->firmware_bootloader_version_);
  build_number_.Swap(&other->build_number_);
  protocol_version_.Swap(&other->protocol_version_);
  bsp_version_.Swap(&other->bsp_version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MuseVersion::GetTypeName() const {
  return "interaxon.muse_data.MuseVersion";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseVersion

// optional string hardware_version = 1;
bool MuseVersion::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MuseVersion::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000001u;
}
void MuseVersion::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void MuseVersion::clear_hardware_version() {
  hardware_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_version();
}
 const ::std::string& MuseVersion::hardware_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.hardware_version)
  return hardware_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.hardware_version)
}
 void MuseVersion::set_hardware_version(const char* value) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.hardware_version)
}
 void MuseVersion::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.hardware_version)
}
 ::std::string* MuseVersion::mutable_hardware_version() {
  set_has_hardware_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.hardware_version)
  return hardware_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_hardware_version() {
  clear_has_hardware_version();
  return hardware_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version != NULL) {
    set_has_hardware_version();
  } else {
    clear_has_hardware_version();
  }
  hardware_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.hardware_version)
}

// optional string firmware_headset_version = 2;
bool MuseVersion::has_firmware_headset_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MuseVersion::set_has_firmware_headset_version() {
  _has_bits_[0] |= 0x00000002u;
}
void MuseVersion::clear_has_firmware_headset_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void MuseVersion::clear_firmware_headset_version() {
  firmware_headset_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_headset_version();
}
 const ::std::string& MuseVersion::firmware_headset_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_headset_version)
  return firmware_headset_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_firmware_headset_version(const ::std::string& value) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
 void MuseVersion::set_firmware_headset_version(const char* value) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
 void MuseVersion::set_firmware_headset_version(const char* value, size_t size) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
 ::std::string* MuseVersion::mutable_firmware_headset_version() {
  set_has_firmware_headset_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_headset_version)
  return firmware_headset_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_firmware_headset_version() {
  clear_has_firmware_headset_version();
  return firmware_headset_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_firmware_headset_version(::std::string* firmware_headset_version) {
  if (firmware_headset_version != NULL) {
    set_has_firmware_headset_version();
  } else {
    clear_has_firmware_headset_version();
  }
  firmware_headset_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_headset_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_headset_version)
}

// optional string firmware_type = 3;
bool MuseVersion::has_firmware_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MuseVersion::set_has_firmware_type() {
  _has_bits_[0] |= 0x00000004u;
}
void MuseVersion::clear_has_firmware_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void MuseVersion::clear_firmware_type() {
  firmware_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_type();
}
 const ::std::string& MuseVersion::firmware_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_type)
  return firmware_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_firmware_type(const ::std::string& value) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_type)
}
 void MuseVersion::set_firmware_type(const char* value) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_type)
}
 void MuseVersion::set_firmware_type(const char* value, size_t size) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_type)
}
 ::std::string* MuseVersion::mutable_firmware_type() {
  set_has_firmware_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_type)
  return firmware_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_firmware_type() {
  clear_has_firmware_type();
  return firmware_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_firmware_type(::std::string* firmware_type) {
  if (firmware_type != NULL) {
    set_has_firmware_type();
  } else {
    clear_has_firmware_type();
  }
  firmware_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_type)
}

// optional string firmware_bootloader_version = 4;
bool MuseVersion::has_firmware_bootloader_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void MuseVersion::set_has_firmware_bootloader_version() {
  _has_bits_[0] |= 0x00000008u;
}
void MuseVersion::clear_has_firmware_bootloader_version() {
  _has_bits_[0] &= ~0x00000008u;
}
void MuseVersion::clear_firmware_bootloader_version() {
  firmware_bootloader_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_bootloader_version();
}
 const ::std::string& MuseVersion::firmware_bootloader_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
  return firmware_bootloader_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_firmware_bootloader_version(const ::std::string& value) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
 void MuseVersion::set_firmware_bootloader_version(const char* value) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
 void MuseVersion::set_firmware_bootloader_version(const char* value, size_t size) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
 ::std::string* MuseVersion::mutable_firmware_bootloader_version() {
  set_has_firmware_bootloader_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
  return firmware_bootloader_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_firmware_bootloader_version() {
  clear_has_firmware_bootloader_version();
  return firmware_bootloader_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_firmware_bootloader_version(::std::string* firmware_bootloader_version) {
  if (firmware_bootloader_version != NULL) {
    set_has_firmware_bootloader_version();
  } else {
    clear_has_firmware_bootloader_version();
  }
  firmware_bootloader_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_bootloader_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}

// optional string build_number = 5;
bool MuseVersion::has_build_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void MuseVersion::set_has_build_number() {
  _has_bits_[0] |= 0x00000010u;
}
void MuseVersion::clear_has_build_number() {
  _has_bits_[0] &= ~0x00000010u;
}
void MuseVersion::clear_build_number() {
  build_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_number();
}
 const ::std::string& MuseVersion::build_number() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.build_number)
  return build_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_build_number(const ::std::string& value) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.build_number)
}
 void MuseVersion::set_build_number(const char* value) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.build_number)
}
 void MuseVersion::set_build_number(const char* value, size_t size) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.build_number)
}
 ::std::string* MuseVersion::mutable_build_number() {
  set_has_build_number();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.build_number)
  return build_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_build_number() {
  clear_has_build_number();
  return build_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_build_number(::std::string* build_number) {
  if (build_number != NULL) {
    set_has_build_number();
  } else {
    clear_has_build_number();
  }
  build_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_number);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.build_number)
}

// optional string protocol_version = 6;
bool MuseVersion::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void MuseVersion::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000020u;
}
void MuseVersion::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000020u;
}
void MuseVersion::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_version();
}
 const ::std::string& MuseVersion::protocol_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.protocol_version)
  return protocol_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_protocol_version(const ::std::string& value) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.protocol_version)
}
 void MuseVersion::set_protocol_version(const char* value) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.protocol_version)
}
 void MuseVersion::set_protocol_version(const char* value, size_t size) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.protocol_version)
}
 ::std::string* MuseVersion::mutable_protocol_version() {
  set_has_protocol_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_protocol_version() {
  clear_has_protocol_version();
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    set_has_protocol_version();
  } else {
    clear_has_protocol_version();
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.protocol_version)
}

// optional string bsp_version = 7;
bool MuseVersion::has_bsp_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void MuseVersion::set_has_bsp_version() {
  _has_bits_[0] |= 0x00000040u;
}
void MuseVersion::clear_has_bsp_version() {
  _has_bits_[0] &= ~0x00000040u;
}
void MuseVersion::clear_bsp_version() {
  bsp_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bsp_version();
}
 const ::std::string& MuseVersion::bsp_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.bsp_version)
  return bsp_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_bsp_version(const ::std::string& value) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.bsp_version)
}
 void MuseVersion::set_bsp_version(const char* value) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.bsp_version)
}
 void MuseVersion::set_bsp_version(const char* value, size_t size) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.bsp_version)
}
 ::std::string* MuseVersion::mutable_bsp_version() {
  set_has_bsp_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.bsp_version)
  return bsp_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseVersion::release_bsp_version() {
  clear_has_bsp_version();
  return bsp_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseVersion::set_allocated_bsp_version(::std::string* bsp_version) {
  if (bsp_version != NULL) {
    set_has_bsp_version();
  } else {
    clear_has_bsp_version();
  }
  bsp_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bsp_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.bsp_version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool MuseConfig_MuseModel_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MuseConfig_MuseModel MuseConfig::MU_01;
const MuseConfig_MuseModel MuseConfig::MU_02;
const MuseConfig_MuseModel MuseConfig::MuseModel_MIN;
const MuseConfig_MuseModel MuseConfig::MuseModel_MAX;
const int MuseConfig::MuseModel_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseConfig::kMacAddrFieldNumber;
const int MuseConfig::kSerialNumberFieldNumber;
const int MuseConfig::kPresetFieldNumber;
const int MuseConfig::kModelFieldNumber;
const int MuseConfig::kHeadbandNameFieldNumber;
const int MuseConfig::kMicrocontrollerIdFieldNumber;
const int MuseConfig::kCompressionEnabledFieldNumber;
const int MuseConfig::kFiltersEnabledFieldNumber;
const int MuseConfig::kNotchFrequencyHzFieldNumber;
const int MuseConfig::kEegSampleFrequencyHzFieldNumber;
const int MuseConfig::kEegOutputFrequencyHzFieldNumber;
const int MuseConfig::kEegSamplesBitwidthFieldNumber;
const int MuseConfig::kEegChannelCountFieldNumber;
const int MuseConfig::kEegChannelLayoutFieldNumber;
const int MuseConfig::kEegDownsampleFieldNumber;
const int MuseConfig::kEegUnitsFieldNumber;
const int MuseConfig::kEegLocationsFieldNumber;
const int MuseConfig::kEegConversionFactorFieldNumber;
const int MuseConfig::kAfeGainFieldNumber;
const int MuseConfig::kDrlrefDataEnabledFieldNumber;
const int MuseConfig::kDrlrefConversionFactorFieldNumber;
const int MuseConfig::kDrlrefSampleFrequencyHzFieldNumber;
const int MuseConfig::kAccDataEnabledFieldNumber;
const int MuseConfig::kAccUnitsFieldNumber;
const int MuseConfig::kAccConversionFactorFieldNumber;
const int MuseConfig::kAccSampleFrequencyHzFieldNumber;
const int MuseConfig::kBatteryDataEnabledFieldNumber;
const int MuseConfig::kBatteryPercentRemainingFieldNumber;
const int MuseConfig::kBatteryMillivoltsFieldNumber;
const int MuseConfig::kErrorDataEnabledFieldNumber;
const int MuseConfig::kGyroDataEnabledFieldNumber;
const int MuseConfig::kGyroConversionFactorFieldNumber;
const int MuseConfig::kGyroSampleFrequencyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseConfig::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseConfig >, 11, false >
  MuseConfig::museData(kMuseDataFieldNumber, ::interaxon::muse_data::MuseConfig::default_instance());
MuseConfig::MuseConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseConfig)
}

void MuseConfig::InitAsDefaultInstance() {
}

MuseConfig::MuseConfig(const MuseConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseConfig)
}

void MuseConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mac_addr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  preset_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  model_ = 1;
  headband_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  microcontroller_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  compression_enabled_ = false;
  filters_enabled_ = false;
  notch_frequency_hz_ = 0u;
  eeg_sample_frequency_hz_ = 0u;
  eeg_output_frequency_hz_ = 0u;
  eeg_samples_bitwidth_ = 0u;
  eeg_channel_count_ = 0u;
  eeg_channel_layout_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  eeg_downsample_ = 0u;
  eeg_units_ = 1;
  eeg_conversion_factor_ = 0;
  afe_gain_ = 0;
  drlref_data_enabled_ = false;
  drlref_conversion_factor_ = 0;
  drlref_sample_frequency_hz_ = 0u;
  acc_data_enabled_ = false;
  acc_units_ = 1;
  acc_conversion_factor_ = 0;
  acc_sample_frequency_hz_ = 0u;
  battery_data_enabled_ = false;
  battery_percent_remaining_ = 0u;
  battery_millivolts_ = 0u;
  error_data_enabled_ = false;
  gyro_data_enabled_ = false;
  gyro_conversion_factor_ = 0;
  gyro_sample_frequency_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseConfig::~MuseConfig() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseConfig)
  SharedDtor();
}

void MuseConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mac_addr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  preset_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  headband_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  microcontroller_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  eeg_channel_layout_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseConfig& MuseConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseConfig* MuseConfig::default_instance_ = NULL;

MuseConfig* MuseConfig::New(::google::protobuf::Arena* arena) const {
  MuseConfig* n = new MuseConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseConfig::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MuseConfig*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(compression_enabled_, filters_enabled_);
    if (has_mac_addr()) {
      mac_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_serial_number()) {
      serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_preset()) {
      preset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    model_ = 1;
    if (has_headband_name()) {
      headband_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_microcontroller_id()) {
      microcontroller_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(notch_frequency_hz_, eeg_channel_count_);
    if (has_eeg_channel_layout()) {
      eeg_channel_layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    eeg_downsample_ = 0u;
    eeg_units_ = 1;
  }
  if (_has_bits_[16 / 32] & 16646144u) {
    ZR_(drlref_data_enabled_, acc_data_enabled_);
    ZR_(eeg_conversion_factor_, drlref_sample_frequency_hz_);
    acc_units_ = 1;
  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    ZR_(acc_conversion_factor_, gyro_conversion_factor_);
  }
  gyro_sample_frequency_ = 0u;

#undef ZR_HELPER_
#undef ZR_

  eeg_locations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mac_addr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mac_addr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_serial_number;
        break;
      }

      // optional string serial_number = 2;
      case 2: {
        if (tag == 18) {
         parse_serial_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serial_number()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_preset;
        break;
      }

      // optional string preset = 3;
      case 3: {
        if (tag == 26) {
         parse_preset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_preset()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_model;
        break;
      }

      // optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
      case 4: {
        if (tag == 32) {
         parse_model:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::MuseConfig_MuseModel_IsValid(value)) {
            set_model(static_cast< ::interaxon::muse_data::MuseConfig_MuseModel >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_headband_name;
        break;
      }

      // optional string headband_name = 5;
      case 5: {
        if (tag == 42) {
         parse_headband_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_headband_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_microcontroller_id;
        break;
      }

      // optional string microcontroller_id = 6;
      case 6: {
        if (tag == 50) {
         parse_microcontroller_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_microcontroller_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(800)) goto parse_compression_enabled;
        break;
      }

      // optional bool compression_enabled = 100;
      case 100: {
        if (tag == 800) {
         parse_compression_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &compression_enabled_)));
          set_has_compression_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1608)) goto parse_filters_enabled;
        break;
      }

      // optional bool filters_enabled = 201;
      case 201: {
        if (tag == 1608) {
         parse_filters_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &filters_enabled_)));
          set_has_filters_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1616)) goto parse_notch_frequency_hz;
        break;
      }

      // optional uint32 notch_frequency_hz = 202;
      case 202: {
        if (tag == 1616) {
         parse_notch_frequency_hz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &notch_frequency_hz_)));
          set_has_notch_frequency_hz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1624)) goto parse_eeg_sample_frequency_hz;
        break;
      }

      // optional uint32 eeg_sample_frequency_hz = 203;
      case 203: {
        if (tag == 1624) {
         parse_eeg_sample_frequency_hz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eeg_sample_frequency_hz_)));
          set_has_eeg_sample_frequency_hz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1632)) goto parse_eeg_output_frequency_hz;
        break;
      }

      // optional uint32 eeg_output_frequency_hz = 204;
      case 204: {
        if (tag == 1632) {
         parse_eeg_output_frequency_hz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eeg_output_frequency_hz_)));
          set_has_eeg_output_frequency_hz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1640)) goto parse_eeg_samples_bitwidth;
        break;
      }

      // optional uint32 eeg_samples_bitwidth = 205;
      case 205: {
        if (tag == 1640) {
         parse_eeg_samples_bitwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eeg_samples_bitwidth_)));
          set_has_eeg_samples_bitwidth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1648)) goto parse_eeg_channel_count;
        break;
      }

      // optional uint32 eeg_channel_count = 206;
      case 206: {
        if (tag == 1648) {
         parse_eeg_channel_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eeg_channel_count_)));
          set_has_eeg_channel_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1658)) goto parse_eeg_channel_layout;
        break;
      }

      // optional string eeg_channel_layout = 207;
      case 207: {
        if (tag == 1658) {
         parse_eeg_channel_layout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eeg_channel_layout()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1664)) goto parse_eeg_downsample;
        break;
      }

      // optional uint32 eeg_downsample = 208;
      case 208: {
        if (tag == 1664) {
         parse_eeg_downsample:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eeg_downsample_)));
          set_has_eeg_downsample();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1672)) goto parse_eeg_units;
        break;
      }

      // optional .interaxon.muse_data.EEGUnits eeg_units = 209;
      case 209: {
        if (tag == 1672) {
         parse_eeg_units:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::EEGUnits_IsValid(value)) {
            set_eeg_units(static_cast< ::interaxon::muse_data::EEGUnits >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1680)) goto parse_eeg_locations;
        break;
      }

      // repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
      case 210: {
        if (tag == 1680) {
         parse_eeg_locations:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::HeadLocations_IsValid(value)) {
            add_eeg_locations(static_cast< ::interaxon::muse_data::HeadLocations >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 1682) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 210,
                 ::interaxon::muse_data::HeadLocations_IsValid,
                 &unknown_fields_stream,
                 this->mutable_eeg_locations())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1680)) goto parse_eeg_locations;
        if (input->ExpectTag(1693)) goto parse_eeg_conversion_factor;
        break;
      }

      // optional float eeg_conversion_factor = 211;
      case 211: {
        if (tag == 1693) {
         parse_eeg_conversion_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &eeg_conversion_factor_)));
          set_has_eeg_conversion_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1701)) goto parse_afe_gain;
        break;
      }

      // optional float afe_gain = 212;
      case 212: {
        if (tag == 1701) {
         parse_afe_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &afe_gain_)));
          set_has_afe_gain();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(2400)) goto parse_drlref_data_enabled;
        break;
      }

      // optional bool drlref_data_enabled = 300;
      case 300: {
        if (tag == 2400) {
         parse_drlref_data_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &drlref_data_enabled_)));
          set_has_drlref_data_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(2413)) goto parse_drlref_conversion_factor;
        break;
      }

      // optional float drlref_conversion_factor = 301;
      case 301: {
        if (tag == 2413) {
         parse_drlref_conversion_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &drlref_conversion_factor_)));
          set_has_drlref_conversion_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(2416)) goto parse_drlref_sample_frequency_hz;
        break;
      }

      // optional uint32 drlref_sample_frequency_hz = 302;
      case 302: {
        if (tag == 2416) {
         parse_drlref_sample_frequency_hz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &drlref_sample_frequency_hz_)));
          set_has_drlref_sample_frequency_hz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3200)) goto parse_acc_data_enabled;
        break;
      }

      // optional bool acc_data_enabled = 400;
      case 400: {
        if (tag == 3200) {
         parse_acc_data_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &acc_data_enabled_)));
          set_has_acc_data_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3208)) goto parse_acc_units;
        break;
      }

      // optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
      case 401: {
        if (tag == 3208) {
         parse_acc_units:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::AccelerometerUnits_IsValid(value)) {
            set_acc_units(static_cast< ::interaxon::muse_data::AccelerometerUnits >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3221)) goto parse_acc_conversion_factor;
        break;
      }

      // optional float acc_conversion_factor = 402;
      case 402: {
        if (tag == 3221) {
         parse_acc_conversion_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_conversion_factor_)));
          set_has_acc_conversion_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3224)) goto parse_acc_sample_frequency_hz;
        break;
      }

      // optional uint32 acc_sample_frequency_hz = 403;
      case 403: {
        if (tag == 3224) {
         parse_acc_sample_frequency_hz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_sample_frequency_hz_)));
          set_has_acc_sample_frequency_hz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(4000)) goto parse_battery_data_enabled;
        break;
      }

      // optional bool battery_data_enabled = 500;
      case 500: {
        if (tag == 4000) {
         parse_battery_data_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &battery_data_enabled_)));
          set_has_battery_data_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(4008)) goto parse_battery_percent_remaining;
        break;
      }

      // optional uint32 battery_percent_remaining = 501;
      case 501: {
        if (tag == 4008) {
         parse_battery_percent_remaining:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battery_percent_remaining_)));
          set_has_battery_percent_remaining();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(4016)) goto parse_battery_millivolts;
        break;
      }

      // optional uint32 battery_millivolts = 502;
      case 502: {
        if (tag == 4016) {
         parse_battery_millivolts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battery_millivolts_)));
          set_has_battery_millivolts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(4800)) goto parse_error_data_enabled;
        break;
      }

      // optional bool error_data_enabled = 600;
      case 600: {
        if (tag == 4800) {
         parse_error_data_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &error_data_enabled_)));
          set_has_error_data_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(5600)) goto parse_gyro_data_enabled;
        break;
      }

      // optional bool gyro_data_enabled = 700;
      case 700: {
        if (tag == 5600) {
         parse_gyro_data_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gyro_data_enabled_)));
          set_has_gyro_data_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(5621)) goto parse_gyro_conversion_factor;
        break;
      }

      // optional float gyro_conversion_factor = 702;
      case 702: {
        if (tag == 5621) {
         parse_gyro_conversion_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gyro_conversion_factor_)));
          set_has_gyro_conversion_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(5624)) goto parse_gyro_sample_frequency;
        break;
      }

      // optional uint32 gyro_sample_frequency = 703;
      case 703: {
        if (tag == 5624) {
         parse_gyro_sample_frequency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gyro_sample_frequency_)));
          set_has_gyro_sample_frequency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseConfig)
  return false;
#undef DO_
}

void MuseConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseConfig)
  // optional string mac_addr = 1;
  if (has_mac_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->mac_addr(), output);
  }

  // optional string serial_number = 2;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->serial_number(), output);
  }

  // optional string preset = 3;
  if (has_preset()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->preset(), output);
  }

  // optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
  if (has_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->model(), output);
  }

  // optional string headband_name = 5;
  if (has_headband_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->headband_name(), output);
  }

  // optional string microcontroller_id = 6;
  if (has_microcontroller_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->microcontroller_id(), output);
  }

  // optional bool compression_enabled = 100;
  if (has_compression_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(100, this->compression_enabled(), output);
  }

  // optional bool filters_enabled = 201;
  if (has_filters_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(201, this->filters_enabled(), output);
  }

  // optional uint32 notch_frequency_hz = 202;
  if (has_notch_frequency_hz()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(202, this->notch_frequency_hz(), output);
  }

  // optional uint32 eeg_sample_frequency_hz = 203;
  if (has_eeg_sample_frequency_hz()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(203, this->eeg_sample_frequency_hz(), output);
  }

  // optional uint32 eeg_output_frequency_hz = 204;
  if (has_eeg_output_frequency_hz()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(204, this->eeg_output_frequency_hz(), output);
  }

  // optional uint32 eeg_samples_bitwidth = 205;
  if (has_eeg_samples_bitwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(205, this->eeg_samples_bitwidth(), output);
  }

  // optional uint32 eeg_channel_count = 206;
  if (has_eeg_channel_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(206, this->eeg_channel_count(), output);
  }

  // optional string eeg_channel_layout = 207;
  if (has_eeg_channel_layout()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      207, this->eeg_channel_layout(), output);
  }

  // optional uint32 eeg_downsample = 208;
  if (has_eeg_downsample()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(208, this->eeg_downsample(), output);
  }

  // optional .interaxon.muse_data.EEGUnits eeg_units = 209;
  if (has_eeg_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      209, this->eeg_units(), output);
  }

  // repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
  for (int i = 0; i < this->eeg_locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      210, this->eeg_locations(i), output);
  }

  // optional float eeg_conversion_factor = 211;
  if (has_eeg_conversion_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(211, this->eeg_conversion_factor(), output);
  }

  // optional float afe_gain = 212;
  if (has_afe_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(212, this->afe_gain(), output);
  }

  // optional bool drlref_data_enabled = 300;
  if (has_drlref_data_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(300, this->drlref_data_enabled(), output);
  }

  // optional float drlref_conversion_factor = 301;
  if (has_drlref_conversion_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(301, this->drlref_conversion_factor(), output);
  }

  // optional uint32 drlref_sample_frequency_hz = 302;
  if (has_drlref_sample_frequency_hz()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(302, this->drlref_sample_frequency_hz(), output);
  }

  // optional bool acc_data_enabled = 400;
  if (has_acc_data_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(400, this->acc_data_enabled(), output);
  }

  // optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
  if (has_acc_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      401, this->acc_units(), output);
  }

  // optional float acc_conversion_factor = 402;
  if (has_acc_conversion_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(402, this->acc_conversion_factor(), output);
  }

  // optional uint32 acc_sample_frequency_hz = 403;
  if (has_acc_sample_frequency_hz()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(403, this->acc_sample_frequency_hz(), output);
  }

  // optional bool battery_data_enabled = 500;
  if (has_battery_data_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(500, this->battery_data_enabled(), output);
  }

  // optional uint32 battery_percent_remaining = 501;
  if (has_battery_percent_remaining()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(501, this->battery_percent_remaining(), output);
  }

  // optional uint32 battery_millivolts = 502;
  if (has_battery_millivolts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(502, this->battery_millivolts(), output);
  }

  // optional bool error_data_enabled = 600;
  if (has_error_data_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(600, this->error_data_enabled(), output);
  }

  // optional bool gyro_data_enabled = 700;
  if (has_gyro_data_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(700, this->gyro_data_enabled(), output);
  }

  // optional float gyro_conversion_factor = 702;
  if (has_gyro_conversion_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(702, this->gyro_conversion_factor(), output);
  }

  // optional uint32 gyro_sample_frequency = 703;
  if (has_gyro_sample_frequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(703, this->gyro_sample_frequency(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseConfig)
}

int MuseConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string mac_addr = 1;
    if (has_mac_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mac_addr());
    }

    // optional string serial_number = 2;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serial_number());
    }

    // optional string preset = 3;
    if (has_preset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->preset());
    }

    // optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->model());
    }

    // optional string headband_name = 5;
    if (has_headband_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->headband_name());
    }

    // optional string microcontroller_id = 6;
    if (has_microcontroller_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->microcontroller_id());
    }

    // optional bool compression_enabled = 100;
    if (has_compression_enabled()) {
      total_size += 2 + 1;
    }

    // optional bool filters_enabled = 201;
    if (has_filters_enabled()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint32 notch_frequency_hz = 202;
    if (has_notch_frequency_hz()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->notch_frequency_hz());
    }

    // optional uint32 eeg_sample_frequency_hz = 203;
    if (has_eeg_sample_frequency_hz()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eeg_sample_frequency_hz());
    }

    // optional uint32 eeg_output_frequency_hz = 204;
    if (has_eeg_output_frequency_hz()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eeg_output_frequency_hz());
    }

    // optional uint32 eeg_samples_bitwidth = 205;
    if (has_eeg_samples_bitwidth()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eeg_samples_bitwidth());
    }

    // optional uint32 eeg_channel_count = 206;
    if (has_eeg_channel_count()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eeg_channel_count());
    }

    // optional string eeg_channel_layout = 207;
    if (has_eeg_channel_layout()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eeg_channel_layout());
    }

    // optional uint32 eeg_downsample = 208;
    if (has_eeg_downsample()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eeg_downsample());
    }

    // optional .interaxon.muse_data.EEGUnits eeg_units = 209;
    if (has_eeg_units()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->eeg_units());
    }

  }
  if (_has_bits_[17 / 32] & 16646144u) {
    // optional float eeg_conversion_factor = 211;
    if (has_eeg_conversion_factor()) {
      total_size += 2 + 4;
    }

    // optional float afe_gain = 212;
    if (has_afe_gain()) {
      total_size += 2 + 4;
    }

    // optional bool drlref_data_enabled = 300;
    if (has_drlref_data_enabled()) {
      total_size += 2 + 1;
    }

    // optional float drlref_conversion_factor = 301;
    if (has_drlref_conversion_factor()) {
      total_size += 2 + 4;
    }

    // optional uint32 drlref_sample_frequency_hz = 302;
    if (has_drlref_sample_frequency_hz()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->drlref_sample_frequency_hz());
    }

    // optional bool acc_data_enabled = 400;
    if (has_acc_data_enabled()) {
      total_size += 2 + 1;
    }

    // optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
    if (has_acc_units()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->acc_units());
    }

  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    // optional float acc_conversion_factor = 402;
    if (has_acc_conversion_factor()) {
      total_size += 2 + 4;
    }

    // optional uint32 acc_sample_frequency_hz = 403;
    if (has_acc_sample_frequency_hz()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_sample_frequency_hz());
    }

    // optional bool battery_data_enabled = 500;
    if (has_battery_data_enabled()) {
      total_size += 2 + 1;
    }

    // optional uint32 battery_percent_remaining = 501;
    if (has_battery_percent_remaining()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battery_percent_remaining());
    }

    // optional uint32 battery_millivolts = 502;
    if (has_battery_millivolts()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battery_millivolts());
    }

    // optional bool error_data_enabled = 600;
    if (has_error_data_enabled()) {
      total_size += 2 + 1;
    }

    // optional bool gyro_data_enabled = 700;
    if (has_gyro_data_enabled()) {
      total_size += 2 + 1;
    }

    // optional float gyro_conversion_factor = 702;
    if (has_gyro_conversion_factor()) {
      total_size += 2 + 4;
    }

  }
  // optional uint32 gyro_sample_frequency = 703;
  if (has_gyro_sample_frequency()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->gyro_sample_frequency());
  }

  // repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
  {
    int data_size = 0;
    for (int i = 0; i < this->eeg_locations_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->eeg_locations(i));
    }
    total_size += 2 * this->eeg_locations_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseConfig*>(&from));
}

void MuseConfig::MergeFrom(const MuseConfig& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  eeg_locations_.MergeFrom(from.eeg_locations_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mac_addr()) {
      set_has_mac_addr();
      mac_addr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mac_addr_);
    }
    if (from.has_serial_number()) {
      set_has_serial_number();
      serial_number_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.serial_number_);
    }
    if (from.has_preset()) {
      set_has_preset();
      preset_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.preset_);
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_headband_name()) {
      set_has_headband_name();
      headband_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.headband_name_);
    }
    if (from.has_microcontroller_id()) {
      set_has_microcontroller_id();
      microcontroller_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.microcontroller_id_);
    }
    if (from.has_compression_enabled()) {
      set_compression_enabled(from.compression_enabled());
    }
    if (from.has_filters_enabled()) {
      set_filters_enabled(from.filters_enabled());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_notch_frequency_hz()) {
      set_notch_frequency_hz(from.notch_frequency_hz());
    }
    if (from.has_eeg_sample_frequency_hz()) {
      set_eeg_sample_frequency_hz(from.eeg_sample_frequency_hz());
    }
    if (from.has_eeg_output_frequency_hz()) {
      set_eeg_output_frequency_hz(from.eeg_output_frequency_hz());
    }
    if (from.has_eeg_samples_bitwidth()) {
      set_eeg_samples_bitwidth(from.eeg_samples_bitwidth());
    }
    if (from.has_eeg_channel_count()) {
      set_eeg_channel_count(from.eeg_channel_count());
    }
    if (from.has_eeg_channel_layout()) {
      set_has_eeg_channel_layout();
      eeg_channel_layout_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.eeg_channel_layout_);
    }
    if (from.has_eeg_downsample()) {
      set_eeg_downsample(from.eeg_downsample());
    }
    if (from.has_eeg_units()) {
      set_eeg_units(from.eeg_units());
    }
  }
  if (from._has_bits_[17 / 32] & (0xffu << (17 % 32))) {
    if (from.has_eeg_conversion_factor()) {
      set_eeg_conversion_factor(from.eeg_conversion_factor());
    }
    if (from.has_afe_gain()) {
      set_afe_gain(from.afe_gain());
    }
    if (from.has_drlref_data_enabled()) {
      set_drlref_data_enabled(from.drlref_data_enabled());
    }
    if (from.has_drlref_conversion_factor()) {
      set_drlref_conversion_factor(from.drlref_conversion_factor());
    }
    if (from.has_drlref_sample_frequency_hz()) {
      set_drlref_sample_frequency_hz(from.drlref_sample_frequency_hz());
    }
    if (from.has_acc_data_enabled()) {
      set_acc_data_enabled(from.acc_data_enabled());
    }
    if (from.has_acc_units()) {
      set_acc_units(from.acc_units());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_acc_conversion_factor()) {
      set_acc_conversion_factor(from.acc_conversion_factor());
    }
    if (from.has_acc_sample_frequency_hz()) {
      set_acc_sample_frequency_hz(from.acc_sample_frequency_hz());
    }
    if (from.has_battery_data_enabled()) {
      set_battery_data_enabled(from.battery_data_enabled());
    }
    if (from.has_battery_percent_remaining()) {
      set_battery_percent_remaining(from.battery_percent_remaining());
    }
    if (from.has_battery_millivolts()) {
      set_battery_millivolts(from.battery_millivolts());
    }
    if (from.has_error_data_enabled()) {
      set_error_data_enabled(from.error_data_enabled());
    }
    if (from.has_gyro_data_enabled()) {
      set_gyro_data_enabled(from.gyro_data_enabled());
    }
    if (from.has_gyro_conversion_factor()) {
      set_gyro_conversion_factor(from.gyro_conversion_factor());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_gyro_sample_frequency()) {
      set_gyro_sample_frequency(from.gyro_sample_frequency());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseConfig::CopyFrom(const MuseConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseConfig::IsInitialized() const {

  return true;
}

void MuseConfig::Swap(MuseConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseConfig::InternalSwap(MuseConfig* other) {
  mac_addr_.Swap(&other->mac_addr_);
  serial_number_.Swap(&other->serial_number_);
  preset_.Swap(&other->preset_);
  std::swap(model_, other->model_);
  headband_name_.Swap(&other->headband_name_);
  microcontroller_id_.Swap(&other->microcontroller_id_);
  std::swap(compression_enabled_, other->compression_enabled_);
  std::swap(filters_enabled_, other->filters_enabled_);
  std::swap(notch_frequency_hz_, other->notch_frequency_hz_);
  std::swap(eeg_sample_frequency_hz_, other->eeg_sample_frequency_hz_);
  std::swap(eeg_output_frequency_hz_, other->eeg_output_frequency_hz_);
  std::swap(eeg_samples_bitwidth_, other->eeg_samples_bitwidth_);
  std::swap(eeg_channel_count_, other->eeg_channel_count_);
  eeg_channel_layout_.Swap(&other->eeg_channel_layout_);
  std::swap(eeg_downsample_, other->eeg_downsample_);
  std::swap(eeg_units_, other->eeg_units_);
  eeg_locations_.UnsafeArenaSwap(&other->eeg_locations_);
  std::swap(eeg_conversion_factor_, other->eeg_conversion_factor_);
  std::swap(afe_gain_, other->afe_gain_);
  std::swap(drlref_data_enabled_, other->drlref_data_enabled_);
  std::swap(drlref_conversion_factor_, other->drlref_conversion_factor_);
  std::swap(drlref_sample_frequency_hz_, other->drlref_sample_frequency_hz_);
  std::swap(acc_data_enabled_, other->acc_data_enabled_);
  std::swap(acc_units_, other->acc_units_);
  std::swap(acc_conversion_factor_, other->acc_conversion_factor_);
  std::swap(acc_sample_frequency_hz_, other->acc_sample_frequency_hz_);
  std::swap(battery_data_enabled_, other->battery_data_enabled_);
  std::swap(battery_percent_remaining_, other->battery_percent_remaining_);
  std::swap(battery_millivolts_, other->battery_millivolts_);
  std::swap(error_data_enabled_, other->error_data_enabled_);
  std::swap(gyro_data_enabled_, other->gyro_data_enabled_);
  std::swap(gyro_conversion_factor_, other->gyro_conversion_factor_);
  std::swap(gyro_sample_frequency_, other->gyro_sample_frequency_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MuseConfig::GetTypeName() const {
  return "interaxon.muse_data.MuseConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseConfig

// optional string mac_addr = 1;
bool MuseConfig::has_mac_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MuseConfig::set_has_mac_addr() {
  _has_bits_[0] |= 0x00000001u;
}
void MuseConfig::clear_has_mac_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
void MuseConfig::clear_mac_addr() {
  mac_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mac_addr();
}
 const ::std::string& MuseConfig::mac_addr() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.mac_addr)
  return mac_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_mac_addr(const ::std::string& value) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.mac_addr)
}
 void MuseConfig::set_mac_addr(const char* value) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.mac_addr)
}
 void MuseConfig::set_mac_addr(const char* value, size_t size) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.mac_addr)
}
 ::std::string* MuseConfig::mutable_mac_addr() {
  set_has_mac_addr();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.mac_addr)
  return mac_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_mac_addr() {
  clear_has_mac_addr();
  return mac_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_mac_addr(::std::string* mac_addr) {
  if (mac_addr != NULL) {
    set_has_mac_addr();
  } else {
    clear_has_mac_addr();
  }
  mac_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_addr);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.mac_addr)
}

// optional string serial_number = 2;
bool MuseConfig::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MuseConfig::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
void MuseConfig::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void MuseConfig::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serial_number();
}
 const ::std::string& MuseConfig::serial_number() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.serial_number)
  return serial_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.serial_number)
}
 void MuseConfig::set_serial_number(const char* value) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.serial_number)
}
 void MuseConfig::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.serial_number)
}
 ::std::string* MuseConfig::mutable_serial_number() {
  set_has_serial_number();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_serial_number() {
  clear_has_serial_number();
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    set_has_serial_number();
  } else {
    clear_has_serial_number();
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.serial_number)
}

// optional string preset = 3;
bool MuseConfig::has_preset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MuseConfig::set_has_preset() {
  _has_bits_[0] |= 0x00000004u;
}
void MuseConfig::clear_has_preset() {
  _has_bits_[0] &= ~0x00000004u;
}
void MuseConfig::clear_preset() {
  preset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_preset();
}
 const ::std::string& MuseConfig::preset() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.preset)
  return preset_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_preset(const ::std::string& value) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.preset)
}
 void MuseConfig::set_preset(const char* value) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.preset)
}
 void MuseConfig::set_preset(const char* value, size_t size) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.preset)
}
 ::std::string* MuseConfig::mutable_preset() {
  set_has_preset();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.preset)
  return preset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_preset() {
  clear_has_preset();
  return preset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_preset(::std::string* preset) {
  if (preset != NULL) {
    set_has_preset();
  } else {
    clear_has_preset();
  }
  preset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preset);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.preset)
}

// optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
bool MuseConfig::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void MuseConfig::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
void MuseConfig::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
void MuseConfig::clear_model() {
  model_ = 1;
  clear_has_model();
}
 ::interaxon::muse_data::MuseConfig_MuseModel MuseConfig::model() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.model)
  return static_cast< ::interaxon::muse_data::MuseConfig_MuseModel >(model_);
}
 void MuseConfig::set_model(::interaxon::muse_data::MuseConfig_MuseModel value) {
  assert(::interaxon::muse_data::MuseConfig_MuseModel_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.model)
}

// optional string headband_name = 5;
bool MuseConfig::has_headband_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void MuseConfig::set_has_headband_name() {
  _has_bits_[0] |= 0x00000010u;
}
void MuseConfig::clear_has_headband_name() {
  _has_bits_[0] &= ~0x00000010u;
}
void MuseConfig::clear_headband_name() {
  headband_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headband_name();
}
 const ::std::string& MuseConfig::headband_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.headband_name)
  return headband_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_headband_name(const ::std::string& value) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.headband_name)
}
 void MuseConfig::set_headband_name(const char* value) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.headband_name)
}
 void MuseConfig::set_headband_name(const char* value, size_t size) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.headband_name)
}
 ::std::string* MuseConfig::mutable_headband_name() {
  set_has_headband_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.headband_name)
  return headband_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_headband_name() {
  clear_has_headband_name();
  return headband_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_headband_name(::std::string* headband_name) {
  if (headband_name != NULL) {
    set_has_headband_name();
  } else {
    clear_has_headband_name();
  }
  headband_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headband_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.headband_name)
}

// optional string microcontroller_id = 6;
bool MuseConfig::has_microcontroller_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void MuseConfig::set_has_microcontroller_id() {
  _has_bits_[0] |= 0x00000020u;
}
void MuseConfig::clear_has_microcontroller_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void MuseConfig::clear_microcontroller_id() {
  microcontroller_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_microcontroller_id();
}
 const ::std::string& MuseConfig::microcontroller_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.microcontroller_id)
  return microcontroller_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_microcontroller_id(const ::std::string& value) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.microcontroller_id)
}
 void MuseConfig::set_microcontroller_id(const char* value) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.microcontroller_id)
}
 void MuseConfig::set_microcontroller_id(const char* value, size_t size) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.microcontroller_id)
}
 ::std::string* MuseConfig::mutable_microcontroller_id() {
  set_has_microcontroller_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.microcontroller_id)
  return microcontroller_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_microcontroller_id() {
  clear_has_microcontroller_id();
  return microcontroller_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_microcontroller_id(::std::string* microcontroller_id) {
  if (microcontroller_id != NULL) {
    set_has_microcontroller_id();
  } else {
    clear_has_microcontroller_id();
  }
  microcontroller_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), microcontroller_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.microcontroller_id)
}

// optional bool compression_enabled = 100;
bool MuseConfig::has_compression_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void MuseConfig::set_has_compression_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
void MuseConfig::clear_has_compression_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
void MuseConfig::clear_compression_enabled() {
  compression_enabled_ = false;
  clear_has_compression_enabled();
}
 bool MuseConfig::compression_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.compression_enabled)
  return compression_enabled_;
}
 void MuseConfig::set_compression_enabled(bool value) {
  set_has_compression_enabled();
  compression_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.compression_enabled)
}

// optional bool filters_enabled = 201;
bool MuseConfig::has_filters_enabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void MuseConfig::set_has_filters_enabled() {
  _has_bits_[0] |= 0x00000080u;
}
void MuseConfig::clear_has_filters_enabled() {
  _has_bits_[0] &= ~0x00000080u;
}
void MuseConfig::clear_filters_enabled() {
  filters_enabled_ = false;
  clear_has_filters_enabled();
}
 bool MuseConfig::filters_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.filters_enabled)
  return filters_enabled_;
}
 void MuseConfig::set_filters_enabled(bool value) {
  set_has_filters_enabled();
  filters_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.filters_enabled)
}

// optional uint32 notch_frequency_hz = 202;
bool MuseConfig::has_notch_frequency_hz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void MuseConfig::set_has_notch_frequency_hz() {
  _has_bits_[0] |= 0x00000100u;
}
void MuseConfig::clear_has_notch_frequency_hz() {
  _has_bits_[0] &= ~0x00000100u;
}
void MuseConfig::clear_notch_frequency_hz() {
  notch_frequency_hz_ = 0u;
  clear_has_notch_frequency_hz();
}
 ::google::protobuf::uint32 MuseConfig::notch_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.notch_frequency_hz)
  return notch_frequency_hz_;
}
 void MuseConfig::set_notch_frequency_hz(::google::protobuf::uint32 value) {
  set_has_notch_frequency_hz();
  notch_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.notch_frequency_hz)
}

// optional uint32 eeg_sample_frequency_hz = 203;
bool MuseConfig::has_eeg_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void MuseConfig::set_has_eeg_sample_frequency_hz() {
  _has_bits_[0] |= 0x00000200u;
}
void MuseConfig::clear_has_eeg_sample_frequency_hz() {
  _has_bits_[0] &= ~0x00000200u;
}
void MuseConfig::clear_eeg_sample_frequency_hz() {
  eeg_sample_frequency_hz_ = 0u;
  clear_has_eeg_sample_frequency_hz();
}
 ::google::protobuf::uint32 MuseConfig::eeg_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_sample_frequency_hz)
  return eeg_sample_frequency_hz_;
}
 void MuseConfig::set_eeg_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_eeg_sample_frequency_hz();
  eeg_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_sample_frequency_hz)
}

// optional uint32 eeg_output_frequency_hz = 204;
bool MuseConfig::has_eeg_output_frequency_hz() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void MuseConfig::set_has_eeg_output_frequency_hz() {
  _has_bits_[0] |= 0x00000400u;
}
void MuseConfig::clear_has_eeg_output_frequency_hz() {
  _has_bits_[0] &= ~0x00000400u;
}
void MuseConfig::clear_eeg_output_frequency_hz() {
  eeg_output_frequency_hz_ = 0u;
  clear_has_eeg_output_frequency_hz();
}
 ::google::protobuf::uint32 MuseConfig::eeg_output_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_output_frequency_hz)
  return eeg_output_frequency_hz_;
}
 void MuseConfig::set_eeg_output_frequency_hz(::google::protobuf::uint32 value) {
  set_has_eeg_output_frequency_hz();
  eeg_output_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_output_frequency_hz)
}

// optional uint32 eeg_samples_bitwidth = 205;
bool MuseConfig::has_eeg_samples_bitwidth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void MuseConfig::set_has_eeg_samples_bitwidth() {
  _has_bits_[0] |= 0x00000800u;
}
void MuseConfig::clear_has_eeg_samples_bitwidth() {
  _has_bits_[0] &= ~0x00000800u;
}
void MuseConfig::clear_eeg_samples_bitwidth() {
  eeg_samples_bitwidth_ = 0u;
  clear_has_eeg_samples_bitwidth();
}
 ::google::protobuf::uint32 MuseConfig::eeg_samples_bitwidth() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_samples_bitwidth)
  return eeg_samples_bitwidth_;
}
 void MuseConfig::set_eeg_samples_bitwidth(::google::protobuf::uint32 value) {
  set_has_eeg_samples_bitwidth();
  eeg_samples_bitwidth_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_samples_bitwidth)
}

// optional uint32 eeg_channel_count = 206;
bool MuseConfig::has_eeg_channel_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void MuseConfig::set_has_eeg_channel_count() {
  _has_bits_[0] |= 0x00001000u;
}
void MuseConfig::clear_has_eeg_channel_count() {
  _has_bits_[0] &= ~0x00001000u;
}
void MuseConfig::clear_eeg_channel_count() {
  eeg_channel_count_ = 0u;
  clear_has_eeg_channel_count();
}
 ::google::protobuf::uint32 MuseConfig::eeg_channel_count() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_channel_count)
  return eeg_channel_count_;
}
 void MuseConfig::set_eeg_channel_count(::google::protobuf::uint32 value) {
  set_has_eeg_channel_count();
  eeg_channel_count_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_channel_count)
}

// optional string eeg_channel_layout = 207;
bool MuseConfig::has_eeg_channel_layout() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void MuseConfig::set_has_eeg_channel_layout() {
  _has_bits_[0] |= 0x00002000u;
}
void MuseConfig::clear_has_eeg_channel_layout() {
  _has_bits_[0] &= ~0x00002000u;
}
void MuseConfig::clear_eeg_channel_layout() {
  eeg_channel_layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_eeg_channel_layout();
}
 const ::std::string& MuseConfig::eeg_channel_layout() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_channel_layout)
  return eeg_channel_layout_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_eeg_channel_layout(const ::std::string& value) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
 void MuseConfig::set_eeg_channel_layout(const char* value) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
 void MuseConfig::set_eeg_channel_layout(const char* value, size_t size) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
 ::std::string* MuseConfig::mutable_eeg_channel_layout() {
  set_has_eeg_channel_layout();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.eeg_channel_layout)
  return eeg_channel_layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseConfig::release_eeg_channel_layout() {
  clear_has_eeg_channel_layout();
  return eeg_channel_layout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseConfig::set_allocated_eeg_channel_layout(::std::string* eeg_channel_layout) {
  if (eeg_channel_layout != NULL) {
    set_has_eeg_channel_layout();
  } else {
    clear_has_eeg_channel_layout();
  }
  eeg_channel_layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), eeg_channel_layout);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}

// optional uint32 eeg_downsample = 208;
bool MuseConfig::has_eeg_downsample() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void MuseConfig::set_has_eeg_downsample() {
  _has_bits_[0] |= 0x00004000u;
}
void MuseConfig::clear_has_eeg_downsample() {
  _has_bits_[0] &= ~0x00004000u;
}
void MuseConfig::clear_eeg_downsample() {
  eeg_downsample_ = 0u;
  clear_has_eeg_downsample();
}
 ::google::protobuf::uint32 MuseConfig::eeg_downsample() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_downsample)
  return eeg_downsample_;
}
 void MuseConfig::set_eeg_downsample(::google::protobuf::uint32 value) {
  set_has_eeg_downsample();
  eeg_downsample_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_downsample)
}

// optional .interaxon.muse_data.EEGUnits eeg_units = 209;
bool MuseConfig::has_eeg_units() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void MuseConfig::set_has_eeg_units() {
  _has_bits_[0] |= 0x00008000u;
}
void MuseConfig::clear_has_eeg_units() {
  _has_bits_[0] &= ~0x00008000u;
}
void MuseConfig::clear_eeg_units() {
  eeg_units_ = 1;
  clear_has_eeg_units();
}
 ::interaxon::muse_data::EEGUnits MuseConfig::eeg_units() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_units)
  return static_cast< ::interaxon::muse_data::EEGUnits >(eeg_units_);
}
 void MuseConfig::set_eeg_units(::interaxon::muse_data::EEGUnits value) {
  assert(::interaxon::muse_data::EEGUnits_IsValid(value));
  set_has_eeg_units();
  eeg_units_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_units)
}

// repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
int MuseConfig::eeg_locations_size() const {
  return eeg_locations_.size();
}
void MuseConfig::clear_eeg_locations() {
  eeg_locations_.Clear();
}
 ::interaxon::muse_data::HeadLocations MuseConfig::eeg_locations(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_locations)
  return static_cast< ::interaxon::muse_data::HeadLocations >(eeg_locations_.Get(index));
}
 void MuseConfig::set_eeg_locations(int index, ::interaxon::muse_data::HeadLocations value) {
  assert(::interaxon::muse_data::HeadLocations_IsValid(value));
  eeg_locations_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_locations)
}
 void MuseConfig::add_eeg_locations(::interaxon::muse_data::HeadLocations value) {
  assert(::interaxon::muse_data::HeadLocations_IsValid(value));
  eeg_locations_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseConfig.eeg_locations)
}
 const ::google::protobuf::RepeatedField<int>&
MuseConfig::eeg_locations() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseConfig.eeg_locations)
  return eeg_locations_;
}
 ::google::protobuf::RepeatedField<int>*
MuseConfig::mutable_eeg_locations() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseConfig.eeg_locations)
  return &eeg_locations_;
}

// optional float eeg_conversion_factor = 211;
bool MuseConfig::has_eeg_conversion_factor() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void MuseConfig::set_has_eeg_conversion_factor() {
  _has_bits_[0] |= 0x00020000u;
}
void MuseConfig::clear_has_eeg_conversion_factor() {
  _has_bits_[0] &= ~0x00020000u;
}
void MuseConfig::clear_eeg_conversion_factor() {
  eeg_conversion_factor_ = 0;
  clear_has_eeg_conversion_factor();
}
 float MuseConfig::eeg_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_conversion_factor)
  return eeg_conversion_factor_;
}
 void MuseConfig::set_eeg_conversion_factor(float value) {
  set_has_eeg_conversion_factor();
  eeg_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_conversion_factor)
}

// optional float afe_gain = 212;
bool MuseConfig::has_afe_gain() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void MuseConfig::set_has_afe_gain() {
  _has_bits_[0] |= 0x00040000u;
}
void MuseConfig::clear_has_afe_gain() {
  _has_bits_[0] &= ~0x00040000u;
}
void MuseConfig::clear_afe_gain() {
  afe_gain_ = 0;
  clear_has_afe_gain();
}
 float MuseConfig::afe_gain() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.afe_gain)
  return afe_gain_;
}
 void MuseConfig::set_afe_gain(float value) {
  set_has_afe_gain();
  afe_gain_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.afe_gain)
}

// optional bool drlref_data_enabled = 300;
bool MuseConfig::has_drlref_data_enabled() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void MuseConfig::set_has_drlref_data_enabled() {
  _has_bits_[0] |= 0x00080000u;
}
void MuseConfig::clear_has_drlref_data_enabled() {
  _has_bits_[0] &= ~0x00080000u;
}
void MuseConfig::clear_drlref_data_enabled() {
  drlref_data_enabled_ = false;
  clear_has_drlref_data_enabled();
}
 bool MuseConfig::drlref_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_data_enabled)
  return drlref_data_enabled_;
}
 void MuseConfig::set_drlref_data_enabled(bool value) {
  set_has_drlref_data_enabled();
  drlref_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_data_enabled)
}

// optional float drlref_conversion_factor = 301;
bool MuseConfig::has_drlref_conversion_factor() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void MuseConfig::set_has_drlref_conversion_factor() {
  _has_bits_[0] |= 0x00100000u;
}
void MuseConfig::clear_has_drlref_conversion_factor() {
  _has_bits_[0] &= ~0x00100000u;
}
void MuseConfig::clear_drlref_conversion_factor() {
  drlref_conversion_factor_ = 0;
  clear_has_drlref_conversion_factor();
}
 float MuseConfig::drlref_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_conversion_factor)
  return drlref_conversion_factor_;
}
 void MuseConfig::set_drlref_conversion_factor(float value) {
  set_has_drlref_conversion_factor();
  drlref_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_conversion_factor)
}

// optional uint32 drlref_sample_frequency_hz = 302;
bool MuseConfig::has_drlref_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void MuseConfig::set_has_drlref_sample_frequency_hz() {
  _has_bits_[0] |= 0x00200000u;
}
void MuseConfig::clear_has_drlref_sample_frequency_hz() {
  _has_bits_[0] &= ~0x00200000u;
}
void MuseConfig::clear_drlref_sample_frequency_hz() {
  drlref_sample_frequency_hz_ = 0u;
  clear_has_drlref_sample_frequency_hz();
}
 ::google::protobuf::uint32 MuseConfig::drlref_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_sample_frequency_hz)
  return drlref_sample_frequency_hz_;
}
 void MuseConfig::set_drlref_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_drlref_sample_frequency_hz();
  drlref_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_sample_frequency_hz)
}

// optional bool acc_data_enabled = 400;
bool MuseConfig::has_acc_data_enabled() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void MuseConfig::set_has_acc_data_enabled() {
  _has_bits_[0] |= 0x00400000u;
}
void MuseConfig::clear_has_acc_data_enabled() {
  _has_bits_[0] &= ~0x00400000u;
}
void MuseConfig::clear_acc_data_enabled() {
  acc_data_enabled_ = false;
  clear_has_acc_data_enabled();
}
 bool MuseConfig::acc_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_data_enabled)
  return acc_data_enabled_;
}
 void MuseConfig::set_acc_data_enabled(bool value) {
  set_has_acc_data_enabled();
  acc_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_data_enabled)
}

// optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
bool MuseConfig::has_acc_units() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void MuseConfig::set_has_acc_units() {
  _has_bits_[0] |= 0x00800000u;
}
void MuseConfig::clear_has_acc_units() {
  _has_bits_[0] &= ~0x00800000u;
}
void MuseConfig::clear_acc_units() {
  acc_units_ = 1;
  clear_has_acc_units();
}
 ::interaxon::muse_data::AccelerometerUnits MuseConfig::acc_units() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_units)
  return static_cast< ::interaxon::muse_data::AccelerometerUnits >(acc_units_);
}
 void MuseConfig::set_acc_units(::interaxon::muse_data::AccelerometerUnits value) {
  assert(::interaxon::muse_data::AccelerometerUnits_IsValid(value));
  set_has_acc_units();
  acc_units_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_units)
}

// optional float acc_conversion_factor = 402;
bool MuseConfig::has_acc_conversion_factor() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void MuseConfig::set_has_acc_conversion_factor() {
  _has_bits_[0] |= 0x01000000u;
}
void MuseConfig::clear_has_acc_conversion_factor() {
  _has_bits_[0] &= ~0x01000000u;
}
void MuseConfig::clear_acc_conversion_factor() {
  acc_conversion_factor_ = 0;
  clear_has_acc_conversion_factor();
}
 float MuseConfig::acc_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_conversion_factor)
  return acc_conversion_factor_;
}
 void MuseConfig::set_acc_conversion_factor(float value) {
  set_has_acc_conversion_factor();
  acc_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_conversion_factor)
}

// optional uint32 acc_sample_frequency_hz = 403;
bool MuseConfig::has_acc_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void MuseConfig::set_has_acc_sample_frequency_hz() {
  _has_bits_[0] |= 0x02000000u;
}
void MuseConfig::clear_has_acc_sample_frequency_hz() {
  _has_bits_[0] &= ~0x02000000u;
}
void MuseConfig::clear_acc_sample_frequency_hz() {
  acc_sample_frequency_hz_ = 0u;
  clear_has_acc_sample_frequency_hz();
}
 ::google::protobuf::uint32 MuseConfig::acc_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_sample_frequency_hz)
  return acc_sample_frequency_hz_;
}
 void MuseConfig::set_acc_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_acc_sample_frequency_hz();
  acc_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_sample_frequency_hz)
}

// optional bool battery_data_enabled = 500;
bool MuseConfig::has_battery_data_enabled() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void MuseConfig::set_has_battery_data_enabled() {
  _has_bits_[0] |= 0x04000000u;
}
void MuseConfig::clear_has_battery_data_enabled() {
  _has_bits_[0] &= ~0x04000000u;
}
void MuseConfig::clear_battery_data_enabled() {
  battery_data_enabled_ = false;
  clear_has_battery_data_enabled();
}
 bool MuseConfig::battery_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_data_enabled)
  return battery_data_enabled_;
}
 void MuseConfig::set_battery_data_enabled(bool value) {
  set_has_battery_data_enabled();
  battery_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_data_enabled)
}

// optional uint32 battery_percent_remaining = 501;
bool MuseConfig::has_battery_percent_remaining() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void MuseConfig::set_has_battery_percent_remaining() {
  _has_bits_[0] |= 0x08000000u;
}
void MuseConfig::clear_has_battery_percent_remaining() {
  _has_bits_[0] &= ~0x08000000u;
}
void MuseConfig::clear_battery_percent_remaining() {
  battery_percent_remaining_ = 0u;
  clear_has_battery_percent_remaining();
}
 ::google::protobuf::uint32 MuseConfig::battery_percent_remaining() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_percent_remaining)
  return battery_percent_remaining_;
}
 void MuseConfig::set_battery_percent_remaining(::google::protobuf::uint32 value) {
  set_has_battery_percent_remaining();
  battery_percent_remaining_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_percent_remaining)
}

// optional uint32 battery_millivolts = 502;
bool MuseConfig::has_battery_millivolts() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void MuseConfig::set_has_battery_millivolts() {
  _has_bits_[0] |= 0x10000000u;
}
void MuseConfig::clear_has_battery_millivolts() {
  _has_bits_[0] &= ~0x10000000u;
}
void MuseConfig::clear_battery_millivolts() {
  battery_millivolts_ = 0u;
  clear_has_battery_millivolts();
}
 ::google::protobuf::uint32 MuseConfig::battery_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_millivolts)
  return battery_millivolts_;
}
 void MuseConfig::set_battery_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_millivolts();
  battery_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_millivolts)
}

// optional bool error_data_enabled = 600;
bool MuseConfig::has_error_data_enabled() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void MuseConfig::set_has_error_data_enabled() {
  _has_bits_[0] |= 0x20000000u;
}
void MuseConfig::clear_has_error_data_enabled() {
  _has_bits_[0] &= ~0x20000000u;
}
void MuseConfig::clear_error_data_enabled() {
  error_data_enabled_ = false;
  clear_has_error_data_enabled();
}
 bool MuseConfig::error_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.error_data_enabled)
  return error_data_enabled_;
}
 void MuseConfig::set_error_data_enabled(bool value) {
  set_has_error_data_enabled();
  error_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.error_data_enabled)
}

// optional bool gyro_data_enabled = 700;
bool MuseConfig::has_gyro_data_enabled() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
void MuseConfig::set_has_gyro_data_enabled() {
  _has_bits_[0] |= 0x40000000u;
}
void MuseConfig::clear_has_gyro_data_enabled() {
  _has_bits_[0] &= ~0x40000000u;
}
void MuseConfig::clear_gyro_data_enabled() {
  gyro_data_enabled_ = false;
  clear_has_gyro_data_enabled();
}
 bool MuseConfig::gyro_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_data_enabled)
  return gyro_data_enabled_;
}
 void MuseConfig::set_gyro_data_enabled(bool value) {
  set_has_gyro_data_enabled();
  gyro_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_data_enabled)
}

// optional float gyro_conversion_factor = 702;
bool MuseConfig::has_gyro_conversion_factor() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
void MuseConfig::set_has_gyro_conversion_factor() {
  _has_bits_[0] |= 0x80000000u;
}
void MuseConfig::clear_has_gyro_conversion_factor() {
  _has_bits_[0] &= ~0x80000000u;
}
void MuseConfig::clear_gyro_conversion_factor() {
  gyro_conversion_factor_ = 0;
  clear_has_gyro_conversion_factor();
}
 float MuseConfig::gyro_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_conversion_factor)
  return gyro_conversion_factor_;
}
 void MuseConfig::set_gyro_conversion_factor(float value) {
  set_has_gyro_conversion_factor();
  gyro_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_conversion_factor)
}

// optional uint32 gyro_sample_frequency = 703;
bool MuseConfig::has_gyro_sample_frequency() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
void MuseConfig::set_has_gyro_sample_frequency() {
  _has_bits_[1] |= 0x00000001u;
}
void MuseConfig::clear_has_gyro_sample_frequency() {
  _has_bits_[1] &= ~0x00000001u;
}
void MuseConfig::clear_gyro_sample_frequency() {
  gyro_sample_frequency_ = 0u;
  clear_has_gyro_sample_frequency();
}
 ::google::protobuf::uint32 MuseConfig::gyro_sample_frequency() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_sample_frequency)
  return gyro_sample_frequency_;
}
 void MuseConfig::set_gyro_sample_frequency(::google::protobuf::uint32 value) {
  set_has_gyro_sample_frequency();
  gyro_sample_frequency_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_sample_frequency)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EEG_DroppedSamples::kNumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EEG_DroppedSamples::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::EEG_DroppedSamples >, 11, false >
  EEG_DroppedSamples::museData(kMuseDataFieldNumber, ::interaxon::muse_data::EEG_DroppedSamples::default_instance());
EEG_DroppedSamples::EEG_DroppedSamples()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.EEG_DroppedSamples)
}

void EEG_DroppedSamples::InitAsDefaultInstance() {
}

EEG_DroppedSamples::EEG_DroppedSamples(const EEG_DroppedSamples& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.EEG_DroppedSamples)
}

void EEG_DroppedSamples::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EEG_DroppedSamples::~EEG_DroppedSamples() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.EEG_DroppedSamples)
  SharedDtor();
}

void EEG_DroppedSamples::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void EEG_DroppedSamples::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EEG_DroppedSamples& EEG_DroppedSamples::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

EEG_DroppedSamples* EEG_DroppedSamples::default_instance_ = NULL;

EEG_DroppedSamples* EEG_DroppedSamples::New(::google::protobuf::Arena* arena) const {
  EEG_DroppedSamples* n = new EEG_DroppedSamples;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EEG_DroppedSamples::Clear() {
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EEG_DroppedSamples::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.EEG_DroppedSamples)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 num = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.EEG_DroppedSamples)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.EEG_DroppedSamples)
  return false;
#undef DO_
}

void EEG_DroppedSamples::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.EEG_DroppedSamples)
  // optional uint32 num = 1;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.EEG_DroppedSamples)
}

int EEG_DroppedSamples::ByteSize() const {
  int total_size = 0;

  // optional uint32 num = 1;
  if (has_num()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->num());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EEG_DroppedSamples::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EEG_DroppedSamples*>(&from));
}

void EEG_DroppedSamples::MergeFrom(const EEG_DroppedSamples& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EEG_DroppedSamples::CopyFrom(const EEG_DroppedSamples& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EEG_DroppedSamples::IsInitialized() const {

  return true;
}

void EEG_DroppedSamples::Swap(EEG_DroppedSamples* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EEG_DroppedSamples::InternalSwap(EEG_DroppedSamples* other) {
  std::swap(num_, other->num_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EEG_DroppedSamples::GetTypeName() const {
  return "interaxon.muse_data.EEG_DroppedSamples";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EEG_DroppedSamples

// optional uint32 num = 1;
bool EEG_DroppedSamples::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EEG_DroppedSamples::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
void EEG_DroppedSamples::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
void EEG_DroppedSamples::clear_num() {
  num_ = 0u;
  clear_has_num();
}
 ::google::protobuf::uint32 EEG_DroppedSamples::num() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG_DroppedSamples.num)
  return num_;
}
 void EEG_DroppedSamples::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG_DroppedSamples.num)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ACC_DroppedSamples::kNumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ACC_DroppedSamples::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::ACC_DroppedSamples >, 11, false >
  ACC_DroppedSamples::museData(kMuseDataFieldNumber, ::interaxon::muse_data::ACC_DroppedSamples::default_instance());
ACC_DroppedSamples::ACC_DroppedSamples()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.ACC_DroppedSamples)
}

void ACC_DroppedSamples::InitAsDefaultInstance() {
}

ACC_DroppedSamples::ACC_DroppedSamples(const ACC_DroppedSamples& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.ACC_DroppedSamples)
}

void ACC_DroppedSamples::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACC_DroppedSamples::~ACC_DroppedSamples() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.ACC_DroppedSamples)
  SharedDtor();
}

void ACC_DroppedSamples::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ACC_DroppedSamples::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ACC_DroppedSamples& ACC_DroppedSamples::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

ACC_DroppedSamples* ACC_DroppedSamples::default_instance_ = NULL;

ACC_DroppedSamples* ACC_DroppedSamples::New(::google::protobuf::Arena* arena) const {
  ACC_DroppedSamples* n = new ACC_DroppedSamples;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ACC_DroppedSamples::Clear() {
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ACC_DroppedSamples::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.ACC_DroppedSamples)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 num = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.ACC_DroppedSamples)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.ACC_DroppedSamples)
  return false;
#undef DO_
}

void ACC_DroppedSamples::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.ACC_DroppedSamples)
  // optional uint32 num = 1;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.ACC_DroppedSamples)
}

int ACC_DroppedSamples::ByteSize() const {
  int total_size = 0;

  // optional uint32 num = 1;
  if (has_num()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->num());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACC_DroppedSamples::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ACC_DroppedSamples*>(&from));
}

void ACC_DroppedSamples::MergeFrom(const ACC_DroppedSamples& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ACC_DroppedSamples::CopyFrom(const ACC_DroppedSamples& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACC_DroppedSamples::IsInitialized() const {

  return true;
}

void ACC_DroppedSamples::Swap(ACC_DroppedSamples* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ACC_DroppedSamples::InternalSwap(ACC_DroppedSamples* other) {
  std::swap(num_, other->num_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ACC_DroppedSamples::GetTypeName() const {
  return "interaxon.muse_data.ACC_DroppedSamples";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ACC_DroppedSamples

// optional uint32 num = 1;
bool ACC_DroppedSamples::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ACC_DroppedSamples::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
void ACC_DroppedSamples::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
void ACC_DroppedSamples::clear_num() {
  num_ = 0u;
  clear_has_num();
}
 ::google::protobuf::uint32 ACC_DroppedSamples::num() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ACC_DroppedSamples.num)
  return num_;
}
 void ACC_DroppedSamples::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ACC_DroppedSamples.num)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ComputingDevice::kOsTypeFieldNumber;
const int ComputingDevice::kOsVersionFieldNumber;
const int ComputingDevice::kHardwareModelNameFieldNumber;
const int ComputingDevice::kHardwareModelIdFieldNumber;
const int ComputingDevice::kProcessorNameFieldNumber;
const int ComputingDevice::kProcessorSpeedFieldNumber;
const int ComputingDevice::kNumberOfProcessorsFieldNumber;
const int ComputingDevice::kMemorySizeFieldNumber;
const int ComputingDevice::kBluetoothVersionFieldNumber;
const int ComputingDevice::kTimeZoneFieldNumber;
const int ComputingDevice::kTimeZoneOffsetSecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ComputingDevice::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::ComputingDevice >, 11, false >
  ComputingDevice::museData(kMuseDataFieldNumber, ::interaxon::muse_data::ComputingDevice::default_instance());
ComputingDevice::ComputingDevice()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.ComputingDevice)
}

void ComputingDevice::InitAsDefaultInstance() {
}

ComputingDevice::ComputingDevice(const ComputingDevice& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.ComputingDevice)
}

void ComputingDevice::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  os_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  os_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_model_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  processor_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  processor_speed_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_of_processors_ = 0u;
  memory_size_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bluetooth_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_zone_offset_seconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputingDevice::~ComputingDevice() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.ComputingDevice)
  SharedDtor();
}

void ComputingDevice::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  os_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  os_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_model_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  processor_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  processor_speed_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  memory_size_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bluetooth_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_zone_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ComputingDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ComputingDevice& ComputingDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

ComputingDevice* ComputingDevice::default_instance_ = NULL;

ComputingDevice* ComputingDevice::New(::google::protobuf::Arena* arena) const {
  ComputingDevice* n = new ComputingDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ComputingDevice::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_os_type()) {
      os_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_os_version()) {
      os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_hardware_model_name()) {
      hardware_model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_hardware_model_id()) {
      hardware_model_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_processor_name()) {
      processor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_processor_speed()) {
      processor_speed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    number_of_processors_ = 0u;
    if (has_memory_size()) {
      memory_size_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 1792u) {
    if (has_bluetooth_version()) {
      bluetooth_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_time_zone()) {
      time_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    time_zone_offset_seconds_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ComputingDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.ComputingDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string os_type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_os_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_os_version;
        break;
      }

      // optional string os_version = 2;
      case 2: {
        if (tag == 18) {
         parse_os_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_os_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_hardware_model_name;
        break;
      }

      // optional string hardware_model_name = 3;
      case 3: {
        if (tag == 26) {
         parse_hardware_model_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_model_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_hardware_model_id;
        break;
      }

      // optional string hardware_model_id = 4;
      case 4: {
        if (tag == 34) {
         parse_hardware_model_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_model_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_processor_name;
        break;
      }

      // optional string processor_name = 5;
      case 5: {
        if (tag == 42) {
         parse_processor_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_processor_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_processor_speed;
        break;
      }

      // optional string processor_speed = 6;
      case 6: {
        if (tag == 50) {
         parse_processor_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_processor_speed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_number_of_processors;
        break;
      }

      // optional uint32 number_of_processors = 7;
      case 7: {
        if (tag == 56) {
         parse_number_of_processors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_of_processors_)));
          set_has_number_of_processors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_memory_size;
        break;
      }

      // optional string memory_size = 8;
      case 8: {
        if (tag == 66) {
         parse_memory_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_memory_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_bluetooth_version;
        break;
      }

      // optional string bluetooth_version = 9;
      case 9: {
        if (tag == 74) {
         parse_bluetooth_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bluetooth_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_time_zone;
        break;
      }

      // optional string time_zone = 10;
      case 10: {
        if (tag == 82) {
         parse_time_zone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time_zone()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_time_zone_offset_seconds;
        break;
      }

      // optional sint32 time_zone_offset_seconds = 11;
      case 11: {
        if (tag == 88) {
         parse_time_zone_offset_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &time_zone_offset_seconds_)));
          set_has_time_zone_offset_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.ComputingDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.ComputingDevice)
  return false;
#undef DO_
}

void ComputingDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.ComputingDevice)
  // optional string os_type = 1;
  if (has_os_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->os_type(), output);
  }

  // optional string os_version = 2;
  if (has_os_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->os_version(), output);
  }

  // optional string hardware_model_name = 3;
  if (has_hardware_model_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->hardware_model_name(), output);
  }

  // optional string hardware_model_id = 4;
  if (has_hardware_model_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->hardware_model_id(), output);
  }

  // optional string processor_name = 5;
  if (has_processor_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->processor_name(), output);
  }

  // optional string processor_speed = 6;
  if (has_processor_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->processor_speed(), output);
  }

  // optional uint32 number_of_processors = 7;
  if (has_number_of_processors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->number_of_processors(), output);
  }

  // optional string memory_size = 8;
  if (has_memory_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->memory_size(), output);
  }

  // optional string bluetooth_version = 9;
  if (has_bluetooth_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->bluetooth_version(), output);
  }

  // optional string time_zone = 10;
  if (has_time_zone()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->time_zone(), output);
  }

  // optional sint32 time_zone_offset_seconds = 11;
  if (has_time_zone_offset_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(11, this->time_zone_offset_seconds(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.ComputingDevice)
}

int ComputingDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string os_type = 1;
    if (has_os_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->os_type());
    }

    // optional string os_version = 2;
    if (has_os_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->os_version());
    }

    // optional string hardware_model_name = 3;
    if (has_hardware_model_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_model_name());
    }

    // optional string hardware_model_id = 4;
    if (has_hardware_model_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_model_id());
    }

    // optional string processor_name = 5;
    if (has_processor_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->processor_name());
    }

    // optional string processor_speed = 6;
    if (has_processor_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->processor_speed());
    }

    // optional uint32 number_of_processors = 7;
    if (has_number_of_processors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_of_processors());
    }

    // optional string memory_size = 8;
    if (has_memory_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->memory_size());
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional string bluetooth_version = 9;
    if (has_bluetooth_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bluetooth_version());
    }

    // optional string time_zone = 10;
    if (has_time_zone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->time_zone());
    }

    // optional sint32 time_zone_offset_seconds = 11;
    if (has_time_zone_offset_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->time_zone_offset_seconds());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputingDevice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ComputingDevice*>(&from));
}

void ComputingDevice::MergeFrom(const ComputingDevice& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_os_type()) {
      set_has_os_type();
      os_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.os_type_);
    }
    if (from.has_os_version()) {
      set_has_os_version();
      os_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.os_version_);
    }
    if (from.has_hardware_model_name()) {
      set_has_hardware_model_name();
      hardware_model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hardware_model_name_);
    }
    if (from.has_hardware_model_id()) {
      set_has_hardware_model_id();
      hardware_model_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hardware_model_id_);
    }
    if (from.has_processor_name()) {
      set_has_processor_name();
      processor_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.processor_name_);
    }
    if (from.has_processor_speed()) {
      set_has_processor_speed();
      processor_speed_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.processor_speed_);
    }
    if (from.has_number_of_processors()) {
      set_number_of_processors(from.number_of_processors());
    }
    if (from.has_memory_size()) {
      set_has_memory_size();
      memory_size_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.memory_size_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bluetooth_version()) {
      set_has_bluetooth_version();
      bluetooth_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bluetooth_version_);
    }
    if (from.has_time_zone()) {
      set_has_time_zone();
      time_zone_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.time_zone_);
    }
    if (from.has_time_zone_offset_seconds()) {
      set_time_zone_offset_seconds(from.time_zone_offset_seconds());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ComputingDevice::CopyFrom(const ComputingDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputingDevice::IsInitialized() const {

  return true;
}

void ComputingDevice::Swap(ComputingDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ComputingDevice::InternalSwap(ComputingDevice* other) {
  os_type_.Swap(&other->os_type_);
  os_version_.Swap(&other->os_version_);
  hardware_model_name_.Swap(&other->hardware_model_name_);
  hardware_model_id_.Swap(&other->hardware_model_id_);
  processor_name_.Swap(&other->processor_name_);
  processor_speed_.Swap(&other->processor_speed_);
  std::swap(number_of_processors_, other->number_of_processors_);
  memory_size_.Swap(&other->memory_size_);
  bluetooth_version_.Swap(&other->bluetooth_version_);
  time_zone_.Swap(&other->time_zone_);
  std::swap(time_zone_offset_seconds_, other->time_zone_offset_seconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ComputingDevice::GetTypeName() const {
  return "interaxon.muse_data.ComputingDevice";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ComputingDevice

// optional string os_type = 1;
bool ComputingDevice::has_os_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ComputingDevice::set_has_os_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ComputingDevice::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ComputingDevice::clear_os_type() {
  os_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_type();
}
 const ::std::string& ComputingDevice::os_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.os_type)
  return os_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_os_type(const ::std::string& value) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.os_type)
}
 void ComputingDevice::set_os_type(const char* value) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.os_type)
}
 void ComputingDevice::set_os_type(const char* value, size_t size) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.os_type)
}
 ::std::string* ComputingDevice::mutable_os_type() {
  set_has_os_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.os_type)
  return os_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_os_type() {
  clear_has_os_type();
  return os_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_os_type(::std::string* os_type) {
  if (os_type != NULL) {
    set_has_os_type();
  } else {
    clear_has_os_type();
  }
  os_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.os_type)
}

// optional string os_version = 2;
bool ComputingDevice::has_os_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ComputingDevice::set_has_os_version() {
  _has_bits_[0] |= 0x00000002u;
}
void ComputingDevice::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void ComputingDevice::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_version();
}
 const ::std::string& ComputingDevice::os_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.os_version)
  return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_os_version(const ::std::string& value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.os_version)
}
 void ComputingDevice::set_os_version(const char* value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.os_version)
}
 void ComputingDevice::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.os_version)
}
 ::std::string* ComputingDevice::mutable_os_version() {
  set_has_os_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_os_version() {
  clear_has_os_version();
  return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    set_has_os_version();
  } else {
    clear_has_os_version();
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.os_version)
}

// optional string hardware_model_name = 3;
bool ComputingDevice::has_hardware_model_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ComputingDevice::set_has_hardware_model_name() {
  _has_bits_[0] |= 0x00000004u;
}
void ComputingDevice::clear_has_hardware_model_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void ComputingDevice::clear_hardware_model_name() {
  hardware_model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_model_name();
}
 const ::std::string& ComputingDevice::hardware_model_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.hardware_model_name)
  return hardware_model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_hardware_model_name(const ::std::string& value) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
 void ComputingDevice::set_hardware_model_name(const char* value) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
 void ComputingDevice::set_hardware_model_name(const char* value, size_t size) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
 ::std::string* ComputingDevice::mutable_hardware_model_name() {
  set_has_hardware_model_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.hardware_model_name)
  return hardware_model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_hardware_model_name() {
  clear_has_hardware_model_name();
  return hardware_model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_hardware_model_name(::std::string* hardware_model_name) {
  if (hardware_model_name != NULL) {
    set_has_hardware_model_name();
  } else {
    clear_has_hardware_model_name();
  }
  hardware_model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_model_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.hardware_model_name)
}

// optional string hardware_model_id = 4;
bool ComputingDevice::has_hardware_model_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ComputingDevice::set_has_hardware_model_id() {
  _has_bits_[0] |= 0x00000008u;
}
void ComputingDevice::clear_has_hardware_model_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void ComputingDevice::clear_hardware_model_id() {
  hardware_model_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_model_id();
}
 const ::std::string& ComputingDevice::hardware_model_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.hardware_model_id)
  return hardware_model_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_hardware_model_id(const ::std::string& value) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
 void ComputingDevice::set_hardware_model_id(const char* value) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
 void ComputingDevice::set_hardware_model_id(const char* value, size_t size) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
 ::std::string* ComputingDevice::mutable_hardware_model_id() {
  set_has_hardware_model_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.hardware_model_id)
  return hardware_model_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_hardware_model_id() {
  clear_has_hardware_model_id();
  return hardware_model_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_hardware_model_id(::std::string* hardware_model_id) {
  if (hardware_model_id != NULL) {
    set_has_hardware_model_id();
  } else {
    clear_has_hardware_model_id();
  }
  hardware_model_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_model_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.hardware_model_id)
}

// optional string processor_name = 5;
bool ComputingDevice::has_processor_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ComputingDevice::set_has_processor_name() {
  _has_bits_[0] |= 0x00000010u;
}
void ComputingDevice::clear_has_processor_name() {
  _has_bits_[0] &= ~0x00000010u;
}
void ComputingDevice::clear_processor_name() {
  processor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor_name();
}
 const ::std::string& ComputingDevice::processor_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.processor_name)
  return processor_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_processor_name(const ::std::string& value) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.processor_name)
}
 void ComputingDevice::set_processor_name(const char* value) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.processor_name)
}
 void ComputingDevice::set_processor_name(const char* value, size_t size) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.processor_name)
}
 ::std::string* ComputingDevice::mutable_processor_name() {
  set_has_processor_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.processor_name)
  return processor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_processor_name() {
  clear_has_processor_name();
  return processor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_processor_name(::std::string* processor_name) {
  if (processor_name != NULL) {
    set_has_processor_name();
  } else {
    clear_has_processor_name();
  }
  processor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.processor_name)
}

// optional string processor_speed = 6;
bool ComputingDevice::has_processor_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ComputingDevice::set_has_processor_speed() {
  _has_bits_[0] |= 0x00000020u;
}
void ComputingDevice::clear_has_processor_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
void ComputingDevice::clear_processor_speed() {
  processor_speed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor_speed();
}
 const ::std::string& ComputingDevice::processor_speed() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.processor_speed)
  return processor_speed_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_processor_speed(const ::std::string& value) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.processor_speed)
}
 void ComputingDevice::set_processor_speed(const char* value) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.processor_speed)
}
 void ComputingDevice::set_processor_speed(const char* value, size_t size) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.processor_speed)
}
 ::std::string* ComputingDevice::mutable_processor_speed() {
  set_has_processor_speed();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.processor_speed)
  return processor_speed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_processor_speed() {
  clear_has_processor_speed();
  return processor_speed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_processor_speed(::std::string* processor_speed) {
  if (processor_speed != NULL) {
    set_has_processor_speed();
  } else {
    clear_has_processor_speed();
  }
  processor_speed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor_speed);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.processor_speed)
}

// optional uint32 number_of_processors = 7;
bool ComputingDevice::has_number_of_processors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ComputingDevice::set_has_number_of_processors() {
  _has_bits_[0] |= 0x00000040u;
}
void ComputingDevice::clear_has_number_of_processors() {
  _has_bits_[0] &= ~0x00000040u;
}
void ComputingDevice::clear_number_of_processors() {
  number_of_processors_ = 0u;
  clear_has_number_of_processors();
}
 ::google::protobuf::uint32 ComputingDevice::number_of_processors() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.number_of_processors)
  return number_of_processors_;
}
 void ComputingDevice::set_number_of_processors(::google::protobuf::uint32 value) {
  set_has_number_of_processors();
  number_of_processors_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.number_of_processors)
}

// optional string memory_size = 8;
bool ComputingDevice::has_memory_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ComputingDevice::set_has_memory_size() {
  _has_bits_[0] |= 0x00000080u;
}
void ComputingDevice::clear_has_memory_size() {
  _has_bits_[0] &= ~0x00000080u;
}
void ComputingDevice::clear_memory_size() {
  memory_size_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory_size();
}
 const ::std::string& ComputingDevice::memory_size() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.memory_size)
  return memory_size_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_memory_size(const ::std::string& value) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.memory_size)
}
 void ComputingDevice::set_memory_size(const char* value) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.memory_size)
}
 void ComputingDevice::set_memory_size(const char* value, size_t size) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.memory_size)
}
 ::std::string* ComputingDevice::mutable_memory_size() {
  set_has_memory_size();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.memory_size)
  return memory_size_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_memory_size() {
  clear_has_memory_size();
  return memory_size_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_memory_size(::std::string* memory_size) {
  if (memory_size != NULL) {
    set_has_memory_size();
  } else {
    clear_has_memory_size();
  }
  memory_size_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory_size);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.memory_size)
}

// optional string bluetooth_version = 9;
bool ComputingDevice::has_bluetooth_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ComputingDevice::set_has_bluetooth_version() {
  _has_bits_[0] |= 0x00000100u;
}
void ComputingDevice::clear_has_bluetooth_version() {
  _has_bits_[0] &= ~0x00000100u;
}
void ComputingDevice::clear_bluetooth_version() {
  bluetooth_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_version();
}
 const ::std::string& ComputingDevice::bluetooth_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.bluetooth_version)
  return bluetooth_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_bluetooth_version(const ::std::string& value) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
 void ComputingDevice::set_bluetooth_version(const char* value) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
 void ComputingDevice::set_bluetooth_version(const char* value, size_t size) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
 ::std::string* ComputingDevice::mutable_bluetooth_version() {
  set_has_bluetooth_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.bluetooth_version)
  return bluetooth_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_bluetooth_version() {
  clear_has_bluetooth_version();
  return bluetooth_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_bluetooth_version(::std::string* bluetooth_version) {
  if (bluetooth_version != NULL) {
    set_has_bluetooth_version();
  } else {
    clear_has_bluetooth_version();
  }
  bluetooth_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.bluetooth_version)
}

// optional string time_zone = 10;
bool ComputingDevice::has_time_zone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ComputingDevice::set_has_time_zone() {
  _has_bits_[0] |= 0x00000200u;
}
void ComputingDevice::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00000200u;
}
void ComputingDevice::clear_time_zone() {
  time_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_time_zone();
}
 const ::std::string& ComputingDevice::time_zone() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.time_zone)
  return time_zone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_time_zone(const ::std::string& value) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.time_zone)
}
 void ComputingDevice::set_time_zone(const char* value) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.time_zone)
}
 void ComputingDevice::set_time_zone(const char* value, size_t size) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.time_zone)
}
 ::std::string* ComputingDevice::mutable_time_zone() {
  set_has_time_zone();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.time_zone)
  return time_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputingDevice::release_time_zone() {
  clear_has_time_zone();
  return time_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputingDevice::set_allocated_time_zone(::std::string* time_zone) {
  if (time_zone != NULL) {
    set_has_time_zone();
  } else {
    clear_has_time_zone();
  }
  time_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time_zone);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.time_zone)
}

// optional sint32 time_zone_offset_seconds = 11;
bool ComputingDevice::has_time_zone_offset_seconds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ComputingDevice::set_has_time_zone_offset_seconds() {
  _has_bits_[0] |= 0x00000400u;
}
void ComputingDevice::clear_has_time_zone_offset_seconds() {
  _has_bits_[0] &= ~0x00000400u;
}
void ComputingDevice::clear_time_zone_offset_seconds() {
  time_zone_offset_seconds_ = 0;
  clear_has_time_zone_offset_seconds();
}
 ::google::protobuf::int32 ComputingDevice::time_zone_offset_seconds() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.time_zone_offset_seconds)
  return time_zone_offset_seconds_;
}
 void ComputingDevice::set_time_zone_offset_seconds(::google::protobuf::int32 value) {
  set_has_time_zone_offset_seconds();
  time_zone_offset_seconds_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.time_zone_offset_seconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DSP::kTypeFieldNumber;
const int DSP::kFloatArrayFieldNumber;
const int DSP::kIntArrayFieldNumber;
const int DSP::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DSP::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::DSP >, 11, false >
  DSP::museData(kMuseDataFieldNumber, ::interaxon::muse_data::DSP::default_instance());
DSP::DSP()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.DSP)
}

void DSP::InitAsDefaultInstance() {
}

DSP::DSP(const DSP& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.DSP)
}

void DSP::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DSP::~DSP() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.DSP)
  SharedDtor();
}

void DSP::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void DSP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DSP& DSP::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

DSP* DSP::default_instance_ = NULL;

DSP* DSP::New(::google::protobuf::Arena* arena) const {
  DSP* n = new DSP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DSP::Clear() {
  if (_has_bits_[0 / 32] & 9u) {
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_version()) {
      version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  float_array_.Clear();
  int_array_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DSP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.DSP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_float_array;
        break;
      }

      // repeated float float_array = 2;
      case 2: {
        if (tag == 21) {
         parse_float_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_float_array())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_float_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_float_array;
        if (input->ExpectTag(24)) goto parse_int_array;
        break;
      }

      // repeated uint32 int_array = 3;
      case 3: {
        if (tag == 24) {
         parse_int_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_int_array())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_int_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_int_array;
        if (input->ExpectTag(34)) goto parse_version;
        break;
      }

      // optional string version = 4;
      case 4: {
        if (tag == 34) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.DSP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.DSP)
  return false;
#undef DO_
}

void DSP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.DSP)
  // optional string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // repeated float float_array = 2;
  for (int i = 0; i < this->float_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->float_array(i), output);
  }

  // repeated uint32 int_array = 3;
  for (int i = 0; i < this->int_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->int_array(i), output);
  }

  // optional string version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.DSP)
}

int DSP::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 9u) {
    // optional string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string version = 4;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated float float_array = 2;
  {
    int data_size = 0;
    data_size = 4 * this->float_array_size();
    total_size += 1 * this->float_array_size() + data_size;
  }

  // repeated uint32 int_array = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->int_array_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->int_array(i));
    }
    total_size += 1 * this->int_array_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DSP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DSP*>(&from));
}

void DSP::MergeFrom(const DSP& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  float_array_.MergeFrom(from.float_array_);
  int_array_.MergeFrom(from.int_array_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DSP::CopyFrom(const DSP& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DSP::IsInitialized() const {

  return true;
}

void DSP::Swap(DSP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DSP::InternalSwap(DSP* other) {
  type_.Swap(&other->type_);
  float_array_.UnsafeArenaSwap(&other->float_array_);
  int_array_.UnsafeArenaSwap(&other->int_array_);
  version_.Swap(&other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DSP::GetTypeName() const {
  return "interaxon.muse_data.DSP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DSP

// optional string type = 1;
bool DSP::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DSP::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void DSP::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void DSP::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& DSP::type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DSP::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.type)
}
 void DSP::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.DSP.type)
}
 void DSP::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.DSP.type)
}
 ::std::string* DSP::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.DSP.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DSP::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DSP::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.DSP.type)
}

// repeated float float_array = 2;
int DSP::float_array_size() const {
  return float_array_.size();
}
void DSP::clear_float_array() {
  float_array_.Clear();
}
 float DSP::float_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.float_array)
  return float_array_.Get(index);
}
 void DSP::set_float_array(int index, float value) {
  float_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.float_array)
}
 void DSP::add_float_array(float value) {
  float_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.DSP.float_array)
}
 const ::google::protobuf::RepeatedField< float >&
DSP::float_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.DSP.float_array)
  return float_array_;
}
 ::google::protobuf::RepeatedField< float >*
DSP::mutable_float_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.DSP.float_array)
  return &float_array_;
}

// repeated uint32 int_array = 3;
int DSP::int_array_size() const {
  return int_array_.size();
}
void DSP::clear_int_array() {
  int_array_.Clear();
}
 ::google::protobuf::uint32 DSP::int_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.int_array)
  return int_array_.Get(index);
}
 void DSP::set_int_array(int index, ::google::protobuf::uint32 value) {
  int_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.int_array)
}
 void DSP::add_int_array(::google::protobuf::uint32 value) {
  int_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.DSP.int_array)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DSP::int_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.DSP.int_array)
  return int_array_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DSP::mutable_int_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.DSP.int_array)
  return &int_array_;
}

// optional string version = 4;
bool DSP::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DSP::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
void DSP::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
void DSP::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
 const ::std::string& DSP::version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DSP::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.version)
}
 void DSP::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.DSP.version)
}
 void DSP::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.DSP.version)
}
 ::std::string* DSP::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.DSP.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DSP::release_version() {
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DSP::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.DSP.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseElement::kTypeFieldNumber;
const int MuseElement::kStringTypeFieldNumber;
const int MuseElement::kAlgorithmVersionFieldNumber;
const int MuseElement::kRealArrayFieldNumber;
const int MuseElement::kIntegerArrayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MuseElement::kMuseDataFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
    ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseElement >, 11, false >
  MuseElement::museData(kMuseDataFieldNumber, ::interaxon::muse_data::MuseElement::default_instance());
MuseElement::MuseElement()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:interaxon.muse_data.MuseElement)
}

void MuseElement::InitAsDefaultInstance() {
}

MuseElement::MuseElement(const MuseElement& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:interaxon.muse_data.MuseElement)
}

void MuseElement::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  string_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  algorithm_version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MuseElement::~MuseElement() {
  // @@protoc_insertion_point(destructor:interaxon.muse_data.MuseElement)
  SharedDtor();
}

void MuseElement::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  string_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MuseElement::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MuseElement& MuseElement::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Muse_5fv2_2eproto();
  return *default_instance_;
}

MuseElement* MuseElement::default_instance_ = NULL;

MuseElement* MuseElement::New(::google::protobuf::Arena* arena) const {
  MuseElement* n = new MuseElement;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MuseElement::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MuseElement*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(type_, algorithm_version_);
    if (has_string_type()) {
      string_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  real_array_.Clear();
  integer_array_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool MuseElement::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:interaxon.muse_data.MuseElement)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .interaxon.muse_data.MuseElementType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::interaxon::muse_data::MuseElementType_IsValid(value)) {
            set_type(static_cast< ::interaxon::muse_data::MuseElementType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_string_type;
        break;
      }

      // optional string string_type = 2;
      case 2: {
        if (tag == 18) {
         parse_string_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_algorithm_version;
        break;
      }

      // optional uint32 algorithm_version = 3;
      case 3: {
        if (tag == 24) {
         parse_algorithm_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &algorithm_version_)));
          set_has_algorithm_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_real_array;
        break;
      }

      // repeated double real_array = 4;
      case 4: {
        if (tag == 33) {
         parse_real_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 33, input, this->mutable_real_array())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_real_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_real_array;
        if (input->ExpectTag(40)) goto parse_integer_array;
        break;
      }

      // repeated uint32 integer_array = 5;
      case 5: {
        if (tag == 40) {
         parse_integer_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_integer_array())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_integer_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_integer_array;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:interaxon.muse_data.MuseElement)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:interaxon.muse_data.MuseElement)
  return false;
#undef DO_
}

void MuseElement::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:interaxon.muse_data.MuseElement)
  // optional .interaxon.muse_data.MuseElementType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string string_type = 2;
  if (has_string_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->string_type(), output);
  }

  // optional uint32 algorithm_version = 3;
  if (has_algorithm_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->algorithm_version(), output);
  }

  // repeated double real_array = 4;
  for (int i = 0; i < this->real_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      4, this->real_array(i), output);
  }

  // repeated uint32 integer_array = 5;
  for (int i = 0; i < this->integer_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->integer_array(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:interaxon.muse_data.MuseElement)
}

int MuseElement::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .interaxon.muse_data.MuseElementType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string string_type = 2;
    if (has_string_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string_type());
    }

    // optional uint32 algorithm_version = 3;
    if (has_algorithm_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->algorithm_version());
    }

  }
  // repeated double real_array = 4;
  {
    int data_size = 0;
    data_size = 8 * this->real_array_size();
    total_size += 1 * this->real_array_size() + data_size;
  }

  // repeated uint32 integer_array = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->integer_array_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->integer_array(i));
    }
    total_size += 1 * this->integer_array_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MuseElement::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MuseElement*>(&from));
}

void MuseElement::MergeFrom(const MuseElement& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  real_array_.MergeFrom(from.real_array_);
  integer_array_.MergeFrom(from.integer_array_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_string_type()) {
      set_has_string_type();
      string_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.string_type_);
    }
    if (from.has_algorithm_version()) {
      set_algorithm_version(from.algorithm_version());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MuseElement::CopyFrom(const MuseElement& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MuseElement::IsInitialized() const {

  return true;
}

void MuseElement::Swap(MuseElement* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MuseElement::InternalSwap(MuseElement* other) {
  std::swap(type_, other->type_);
  string_type_.Swap(&other->string_type_);
  std::swap(algorithm_version_, other->algorithm_version_);
  real_array_.UnsafeArenaSwap(&other->real_array_);
  integer_array_.UnsafeArenaSwap(&other->integer_array_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string MuseElement::GetTypeName() const {
  return "interaxon.muse_data.MuseElement";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseElement

// optional .interaxon.muse_data.MuseElementType type = 1;
bool MuseElement::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MuseElement::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void MuseElement::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void MuseElement::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::interaxon::muse_data::MuseElementType MuseElement::type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.type)
  return static_cast< ::interaxon::muse_data::MuseElementType >(type_);
}
 void MuseElement::set_type(::interaxon::muse_data::MuseElementType value) {
  assert(::interaxon::muse_data::MuseElementType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.type)
}

// optional string string_type = 2;
bool MuseElement::has_string_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MuseElement::set_has_string_type() {
  _has_bits_[0] |= 0x00000002u;
}
void MuseElement::clear_has_string_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void MuseElement::clear_string_type() {
  string_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_string_type();
}
 const ::std::string& MuseElement::string_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.string_type)
  return string_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseElement::set_string_type(const ::std::string& value) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.string_type)
}
 void MuseElement::set_string_type(const char* value) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseElement.string_type)
}
 void MuseElement::set_string_type(const char* value, size_t size) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseElement.string_type)
}
 ::std::string* MuseElement::mutable_string_type() {
  set_has_string_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseElement.string_type)
  return string_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MuseElement::release_string_type() {
  clear_has_string_type();
  return string_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MuseElement::set_allocated_string_type(::std::string* string_type) {
  if (string_type != NULL) {
    set_has_string_type();
  } else {
    clear_has_string_type();
  }
  string_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseElement.string_type)
}

// optional uint32 algorithm_version = 3;
bool MuseElement::has_algorithm_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MuseElement::set_has_algorithm_version() {
  _has_bits_[0] |= 0x00000004u;
}
void MuseElement::clear_has_algorithm_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void MuseElement::clear_algorithm_version() {
  algorithm_version_ = 0u;
  clear_has_algorithm_version();
}
 ::google::protobuf::uint32 MuseElement::algorithm_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.algorithm_version)
  return algorithm_version_;
}
 void MuseElement::set_algorithm_version(::google::protobuf::uint32 value) {
  set_has_algorithm_version();
  algorithm_version_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.algorithm_version)
}

// repeated double real_array = 4;
int MuseElement::real_array_size() const {
  return real_array_.size();
}
void MuseElement::clear_real_array() {
  real_array_.Clear();
}
 double MuseElement::real_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.real_array)
  return real_array_.Get(index);
}
 void MuseElement::set_real_array(int index, double value) {
  real_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.real_array)
}
 void MuseElement::add_real_array(double value) {
  real_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseElement.real_array)
}
 const ::google::protobuf::RepeatedField< double >&
MuseElement::real_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseElement.real_array)
  return real_array_;
}
 ::google::protobuf::RepeatedField< double >*
MuseElement::mutable_real_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseElement.real_array)
  return &real_array_;
}

// repeated uint32 integer_array = 5;
int MuseElement::integer_array_size() const {
  return integer_array_.size();
}
void MuseElement::clear_integer_array() {
  integer_array_.Clear();
}
 ::google::protobuf::uint32 MuseElement::integer_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.integer_array)
  return integer_array_.Get(index);
}
 void MuseElement::set_integer_array(int index, ::google::protobuf::uint32 value) {
  integer_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.integer_array)
}
 void MuseElement::add_integer_array(::google::protobuf::uint32 value) {
  integer_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseElement.integer_array)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MuseElement::integer_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseElement.integer_array)
  return integer_array_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MuseElement::mutable_integer_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseElement.integer_array)
  return &integer_array_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace muse_data
}  // namespace interaxon

// @@protoc_insertion_point(global_scope)

#endif
