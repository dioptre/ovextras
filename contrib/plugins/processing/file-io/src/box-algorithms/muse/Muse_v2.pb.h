// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Muse_v2.proto

#ifndef PROTOBUF_Muse_5fv2_2eproto__INCLUDED
#define PROTOBUF_Muse_5fv2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace interaxon {
namespace muse_data {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Muse_5fv2_2eproto();
void protobuf_AssignDesc_Muse_5fv2_2eproto();
void protobuf_ShutdownFile_Muse_5fv2_2eproto();

class ACC_DroppedSamples;
class Accelerometer;
class Annotation;
class Battery;
class ComputingDevice;
class DSP;
class EEG;
class EEG_DroppedSamples;
class Gyro;
class MuseConfig;
class MuseData;
class MuseDataCollection;
class MuseElement;
class MuseQuantization;
class MuseVersion;

enum MuseData_Datatype {
  MuseData_Datatype_EEG = 0,
  MuseData_Datatype_QUANT = 1,
  MuseData_Datatype_ACCEL = 2,
  MuseData_Datatype_BATTERY = 3,
  MuseData_Datatype_VERSION = 4,
  MuseData_Datatype_CONFIG = 5,
  MuseData_Datatype_ANNOTATION = 6,
  MuseData_Datatype_HISTOGRAM = 7,
  MuseData_Datatype_ALGVALUE = 8,
  MuseData_Datatype_DSP = 9,
  MuseData_Datatype_COMPUTING_DEVICE = 10,
  MuseData_Datatype_EEG_DROPPED = 11,
  MuseData_Datatype_ACC_DROPPED = 12,
  MuseData_Datatype_CALM_APP = 13,
  MuseData_Datatype_CALM_ALG = 14,
  MuseData_Datatype_MUSE_ELEMENTS = 15,
  MuseData_Datatype_GYRO = 16
};
bool MuseData_Datatype_IsValid(int value);
const MuseData_Datatype MuseData_Datatype_Datatype_MIN = MuseData_Datatype_EEG;
const MuseData_Datatype MuseData_Datatype_Datatype_MAX = MuseData_Datatype_GYRO;
const int MuseData_Datatype_Datatype_ARRAYSIZE = MuseData_Datatype_Datatype_MAX + 1;

enum Annotation_Format {
  Annotation_Format_PLAIN_STRING = 0,
  Annotation_Format_JSON = 1,
  Annotation_Format_OSC = 2
};
bool Annotation_Format_IsValid(int value);
const Annotation_Format Annotation_Format_Format_MIN = Annotation_Format_PLAIN_STRING;
const Annotation_Format Annotation_Format_Format_MAX = Annotation_Format_OSC;
const int Annotation_Format_Format_ARRAYSIZE = Annotation_Format_Format_MAX + 1;

enum MuseConfig_MuseModel {
  MuseConfig_MuseModel_MU_01 = 1,
  MuseConfig_MuseModel_MU_02 = 2
};
bool MuseConfig_MuseModel_IsValid(int value);
const MuseConfig_MuseModel MuseConfig_MuseModel_MuseModel_MIN = MuseConfig_MuseModel_MU_01;
const MuseConfig_MuseModel MuseConfig_MuseModel_MuseModel_MAX = MuseConfig_MuseModel_MU_02;
const int MuseConfig_MuseModel_MuseModel_ARRAYSIZE = MuseConfig_MuseModel_MuseModel_MAX + 1;

enum HeadLocations {
  NZ = 1,
  FP1 = 2,
  FPZ = 3,
  FP2 = 4,
  AF7 = 5,
  AF3 = 6,
  AFZ = 7,
  AF4 = 8,
  AF8 = 9,
  F9 = 10,
  F7 = 11,
  F5 = 12,
  F3 = 13,
  F1 = 14,
  FZ = 15,
  F2 = 16,
  F4 = 17,
  F6 = 18,
  F8 = 19,
  F10 = 20,
  FT9 = 21,
  FT7 = 22,
  FC5 = 23,
  FC3 = 24,
  FC1 = 25,
  FCZ = 26,
  FC2 = 27,
  FC4 = 28,
  FC6 = 29,
  FT8 = 30,
  FT10 = 31,
  A1 = 32,
  T9 = 33,
  T7 = 34,
  C5 = 35,
  C3 = 36,
  C1 = 37,
  CZ = 38,
  C2 = 39,
  C4 = 40,
  C6 = 41,
  T8 = 42,
  T10 = 43,
  A2 = 44,
  TP9 = 45,
  TP7 = 46,
  CP5 = 47,
  CP3 = 48,
  CP1 = 49,
  CPZ = 50,
  CP2 = 51,
  CP4 = 52,
  CP6 = 53,
  TP8 = 54,
  TP10 = 55,
  P9 = 56,
  P7 = 57,
  P5 = 58,
  P3 = 59,
  P1 = 60,
  PZ = 61,
  P2 = 62,
  P4 = 63,
  P6 = 64,
  P8 = 65,
  P10 = 66,
  PO7 = 67,
  PO3 = 68,
  POZ = 69,
  PO4 = 70,
  PO8 = 71,
  O1 = 72,
  OZ = 73,
  O2 = 74,
  IZ = 75,
  AUX1 = 76,
  AUX2 = 77,
  AUX3 = 78,
  AUX4 = 79,
  MUSE_LEFT_AUX = 80,
  MUSE_RIGHT_AUX = 81
};
bool HeadLocations_IsValid(int value);
const HeadLocations HeadLocations_MIN = NZ;
const HeadLocations HeadLocations_MAX = MUSE_RIGHT_AUX;
const int HeadLocations_ARRAYSIZE = HeadLocations_MAX + 1;

enum EEGUnits {
  EEG_MICROVOLTS = 1,
  EEG_MUSE1_RAW = 2
};
bool EEGUnits_IsValid(int value);
const EEGUnits EEGUnits_MIN = EEG_MICROVOLTS;
const EEGUnits EEGUnits_MAX = EEG_MUSE1_RAW;
const int EEGUnits_ARRAYSIZE = EEGUnits_MAX + 1;

enum AccelerometerUnits {
  ACC_GFORCE = 1,
  ACC_MUSE1_RAW = 2
};
bool AccelerometerUnits_IsValid(int value);
const AccelerometerUnits AccelerometerUnits_MIN = ACC_GFORCE;
const AccelerometerUnits AccelerometerUnits_MAX = ACC_MUSE1_RAW;
const int AccelerometerUnits_ARRAYSIZE = AccelerometerUnits_MAX + 1;

enum MuseElementType {
  STRING_TYPE = 0,
  LOW_FREQ_ABSOLUTE = 1,
  DELTA_ABSOLUTE = 2,
  THETA_ABSOLUTE = 3,
  ALPHA_ABSOLUTE = 4,
  BETA_ABSOLUTE = 5,
  GAMMA_ABSOLUTE = 6,
  LOW_FREQ_RELATIVE = 7,
  DELTA_RELATIVE = 8,
  THETA_RELATIVE = 9,
  ALPHA_RELATIVE = 10,
  BETA_RELATIVE = 11,
  GAMMA_RELATIVE = 12,
  LOW_FREQ_SESSION_SCORE = 13,
  DELTA_SESSION_SCORE = 14,
  THETA_SESSION_SCORE = 15,
  ALPHA_SESSION_SCORE = 16,
  BETA_SESSION_SCORE = 17,
  GAMMA_SESSION_SCORE = 18,
  TOUCHING_FOREHEAD = 19,
  HSI = 20,
  IS_GOOD = 21,
  BLINK = 22,
  JAW_CLENCH = 23
};
bool MuseElementType_IsValid(int value);
const MuseElementType MuseElementType_MIN = STRING_TYPE;
const MuseElementType MuseElementType_MAX = JAW_CLENCH;
const int MuseElementType_ARRAYSIZE = MuseElementType_MAX + 1;

// ===================================================================

class MuseDataCollection : public ::google::protobuf::MessageLite {
 public:
  MuseDataCollection();
  virtual ~MuseDataCollection();

  MuseDataCollection(const MuseDataCollection& from);

  inline MuseDataCollection& operator=(const MuseDataCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseDataCollection& default_instance();

  void Swap(MuseDataCollection* other);

  // implements Message ----------------------------------------------

  inline MuseDataCollection* New() const { return New(NULL); }

  MuseDataCollection* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseDataCollection& from);
  void MergeFrom(const MuseDataCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseDataCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .interaxon.muse_data.MuseData collection = 1;
  int collection_size() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::interaxon::muse_data::MuseData& collection(int index) const;
  ::interaxon::muse_data::MuseData* mutable_collection(int index);
  ::interaxon::muse_data::MuseData* add_collection();
  ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >*
      mutable_collection();
  const ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >&
      collection() const;

  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseDataCollection)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData > collection_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseDataCollection* default_instance_;
};
// -------------------------------------------------------------------

class MuseData : public ::google::protobuf::MessageLite {
 public:
  MuseData();
  virtual ~MuseData();

  MuseData(const MuseData& from);

  inline MuseData& operator=(const MuseData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseData& default_instance();

  void Swap(MuseData* other);

  // implements Message ----------------------------------------------

  inline MuseData* New() const { return New(NULL); }

  MuseData* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseData& from);
  void MergeFrom(const MuseData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MuseData_Datatype Datatype;
  static const Datatype EEG = MuseData_Datatype_EEG;
  static const Datatype QUANT = MuseData_Datatype_QUANT;
  static const Datatype ACCEL = MuseData_Datatype_ACCEL;
  static const Datatype BATTERY = MuseData_Datatype_BATTERY;
  static const Datatype VERSION = MuseData_Datatype_VERSION;
  static const Datatype CONFIG = MuseData_Datatype_CONFIG;
  static const Datatype ANNOTATION = MuseData_Datatype_ANNOTATION;
  static const Datatype HISTOGRAM = MuseData_Datatype_HISTOGRAM;
  static const Datatype ALGVALUE = MuseData_Datatype_ALGVALUE;
  static const Datatype DSP = MuseData_Datatype_DSP;
  static const Datatype COMPUTING_DEVICE = MuseData_Datatype_COMPUTING_DEVICE;
  static const Datatype EEG_DROPPED = MuseData_Datatype_EEG_DROPPED;
  static const Datatype ACC_DROPPED = MuseData_Datatype_ACC_DROPPED;
  static const Datatype CALM_APP = MuseData_Datatype_CALM_APP;
  static const Datatype CALM_ALG = MuseData_Datatype_CALM_ALG;
  static const Datatype MUSE_ELEMENTS = MuseData_Datatype_MUSE_ELEMENTS;
  static const Datatype GYRO = MuseData_Datatype_GYRO;
  static inline bool Datatype_IsValid(int value) {
    return MuseData_Datatype_IsValid(value);
  }
  static const Datatype Datatype_MIN =
    MuseData_Datatype_Datatype_MIN;
  static const Datatype Datatype_MAX =
    MuseData_Datatype_Datatype_MAX;
  static const int Datatype_ARRAYSIZE =
    MuseData_Datatype_Datatype_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // required .interaxon.muse_data.MuseData.Datatype datatype = 2;
  bool has_datatype() const;
  void clear_datatype();
  static const int kDatatypeFieldNumber = 2;
  ::interaxon::muse_data::MuseData_Datatype datatype() const;
  void set_datatype(::interaxon::muse_data::MuseData_Datatype value);

  // optional uint64 config_id = 3;
  bool has_config_id() const;
  void clear_config_id();
  static const int kConfigIdFieldNumber = 3;
  ::google::protobuf::uint64 config_id() const;
  void set_config_id(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MuseData)
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseData)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_datatype();
  inline void clear_has_datatype();
  inline void set_has_config_id();
  inline void clear_has_config_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double timestamp_;
  ::google::protobuf::uint64 config_id_;
  int datatype_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseData* default_instance_;
};
// -------------------------------------------------------------------

class EEG : public ::google::protobuf::MessageLite {
 public:
  EEG();
  virtual ~EEG();

  EEG(const EEG& from);

  inline EEG& operator=(const EEG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EEG& default_instance();

  void Swap(EEG* other);

  // implements Message ----------------------------------------------

  inline EEG* New() const { return New(NULL); }

  EEG* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EEG& from);
  void MergeFrom(const EEG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EEG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // optional float drl = 5;
  bool has_drl() const;
  void clear_drl();
  static const int kDrlFieldNumber = 5;
  float drl() const;
  void set_drl(float value);

  // optional float ref = 6;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 6;
  float ref() const;
  void set_ref(float value);

  static const int kMuseDataFieldNumber = 8;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::EEG >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.EEG)
 private:
  inline void set_has_drl();
  inline void clear_has_drl();
  inline void set_has_ref();
  inline void clear_has_ref();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > values_;
  float drl_;
  float ref_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static EEG* default_instance_;
};
// -------------------------------------------------------------------

class MuseQuantization : public ::google::protobuf::MessageLite {
 public:
  MuseQuantization();
  virtual ~MuseQuantization();

  MuseQuantization(const MuseQuantization& from);

  inline MuseQuantization& operator=(const MuseQuantization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseQuantization& default_instance();

  void Swap(MuseQuantization* other);

  // implements Message ----------------------------------------------

  inline MuseQuantization* New() const { return New(NULL); }

  MuseQuantization* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseQuantization& from);
  void MergeFrom(const MuseQuantization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseQuantization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint32 values(int index) const;
  void set_values(int index, ::google::protobuf::uint32 value);
  void add_values(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  static const int kMuseDataFieldNumber = 9;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseQuantization >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseQuantization)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseQuantization* default_instance_;
};
// -------------------------------------------------------------------

class Accelerometer : public ::google::protobuf::MessageLite {
 public:
  Accelerometer();
  virtual ~Accelerometer();

  Accelerometer(const Accelerometer& from);

  inline Accelerometer& operator=(const Accelerometer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Accelerometer& default_instance();

  void Swap(Accelerometer* other);

  // implements Message ----------------------------------------------

  inline Accelerometer* New() const { return New(NULL); }

  Accelerometer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Accelerometer& from);
  void MergeFrom(const Accelerometer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Accelerometer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float acc1 = 1;
  bool has_acc1() const;
  void clear_acc1();
  static const int kAcc1FieldNumber = 1;
  float acc1() const;
  void set_acc1(float value);

  // optional float acc2 = 2;
  bool has_acc2() const;
  void clear_acc2();
  static const int kAcc2FieldNumber = 2;
  float acc2() const;
  void set_acc2(float value);

  // optional float acc3 = 3;
  bool has_acc3() const;
  void clear_acc3();
  static const int kAcc3FieldNumber = 3;
  float acc3() const;
  void set_acc3(float value);

  static const int kMuseDataFieldNumber = 10;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Accelerometer >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.Accelerometer)
 private:
  inline void set_has_acc1();
  inline void clear_has_acc1();
  inline void set_has_acc2();
  inline void clear_has_acc2();
  inline void set_has_acc3();
  inline void clear_has_acc3();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float acc1_;
  float acc2_;
  float acc3_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static Accelerometer* default_instance_;
};
// -------------------------------------------------------------------

class Gyro : public ::google::protobuf::MessageLite {
 public:
  Gyro();
  virtual ~Gyro();

  Gyro(const Gyro& from);

  inline Gyro& operator=(const Gyro& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Gyro& default_instance();

  void Swap(Gyro* other);

  // implements Message ----------------------------------------------

  inline Gyro* New() const { return New(NULL); }

  Gyro* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Gyro& from);
  void MergeFrom(const Gyro& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gyro* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float gyro1 = 1;
  bool has_gyro1() const;
  void clear_gyro1();
  static const int kGyro1FieldNumber = 1;
  float gyro1() const;
  void set_gyro1(float value);

  // optional float gyro2 = 2;
  bool has_gyro2() const;
  void clear_gyro2();
  static const int kGyro2FieldNumber = 2;
  float gyro2() const;
  void set_gyro2(float value);

  // optional float gyro3 = 3;
  bool has_gyro3() const;
  void clear_gyro3();
  static const int kGyro3FieldNumber = 3;
  float gyro3() const;
  void set_gyro3(float value);

  static const int kMuseDataFieldNumber = 12;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Gyro >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.Gyro)
 private:
  inline void set_has_gyro1();
  inline void clear_has_gyro1();
  inline void set_has_gyro2();
  inline void clear_has_gyro2();
  inline void set_has_gyro3();
  inline void clear_has_gyro3();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float gyro1_;
  float gyro2_;
  float gyro3_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static Gyro* default_instance_;
};
// -------------------------------------------------------------------

class Annotation : public ::google::protobuf::MessageLite {
 public:
  Annotation();
  virtual ~Annotation();

  Annotation(const Annotation& from);

  inline Annotation& operator=(const Annotation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Annotation& default_instance();

  void Swap(Annotation* other);

  // implements Message ----------------------------------------------

  inline Annotation* New() const { return New(NULL); }

  Annotation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Annotation& from);
  void MergeFrom(const Annotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Annotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Annotation_Format Format;
  static const Format PLAIN_STRING = Annotation_Format_PLAIN_STRING;
  static const Format JSON = Annotation_Format_JSON;
  static const Format OSC = Annotation_Format_OSC;
  static inline bool Format_IsValid(int value) {
    return Annotation_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Annotation_Format_Format_MIN;
  static const Format Format_MAX =
    Annotation_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Annotation_Format_Format_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string event_data = 1;
  bool has_event_data() const;
  void clear_event_data();
  static const int kEventDataFieldNumber = 1;
  const ::std::string& event_data() const;
  void set_event_data(const ::std::string& value);
  void set_event_data(const char* value);
  void set_event_data(const char* value, size_t size);
  ::std::string* mutable_event_data();
  ::std::string* release_event_data();
  void set_allocated_event_data(::std::string* event_data);

  // optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
  bool has_event_data_format() const;
  void clear_event_data_format();
  static const int kEventDataFormatFieldNumber = 2;
  ::interaxon::muse_data::Annotation_Format event_data_format() const;
  void set_event_data_format(::interaxon::muse_data::Annotation_Format value);

  // optional string event_type = 3;
  bool has_event_type() const;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 3;
  const ::std::string& event_type() const;
  void set_event_type(const ::std::string& value);
  void set_event_type(const char* value);
  void set_event_type(const char* value, size_t size);
  ::std::string* mutable_event_type();
  ::std::string* release_event_type();
  void set_allocated_event_type(::std::string* event_type);

  // optional string event_id = 4;
  bool has_event_id() const;
  void clear_event_id();
  static const int kEventIdFieldNumber = 4;
  const ::std::string& event_id() const;
  void set_event_id(const ::std::string& value);
  void set_event_id(const char* value);
  void set_event_id(const char* value, size_t size);
  ::std::string* mutable_event_id();
  ::std::string* release_event_id();
  void set_allocated_event_id(::std::string* event_id);

  // optional string parent_id = 5;
  bool has_parent_id() const;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 5;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  void set_parent_id(const char* value);
  void set_parent_id(const char* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  static const int kMuseDataFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Annotation >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.Annotation)
 private:
  inline void set_has_event_data();
  inline void clear_has_event_data();
  inline void set_has_event_data_format();
  inline void clear_has_event_data_format();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr event_data_;
  ::google::protobuf::internal::ArenaStringPtr event_type_;
  ::google::protobuf::internal::ArenaStringPtr event_id_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  int event_data_format_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static Annotation* default_instance_;
};
// -------------------------------------------------------------------

class Battery : public ::google::protobuf::MessageLite {
 public:
  Battery();
  virtual ~Battery();

  Battery(const Battery& from);

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Battery& default_instance();

  void Swap(Battery* other);

  // implements Message ----------------------------------------------

  inline Battery* New() const { return New(NULL); }

  Battery* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Battery& from);
  void MergeFrom(const Battery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 percent_remaining = 1;
  bool has_percent_remaining() const;
  void clear_percent_remaining();
  static const int kPercentRemainingFieldNumber = 1;
  ::google::protobuf::uint32 percent_remaining() const;
  void set_percent_remaining(::google::protobuf::uint32 value);

  // optional uint32 battery_fuel_gauge_millivolts = 2;
  bool has_battery_fuel_gauge_millivolts() const;
  void clear_battery_fuel_gauge_millivolts();
  static const int kBatteryFuelGaugeMillivoltsFieldNumber = 2;
  ::google::protobuf::uint32 battery_fuel_gauge_millivolts() const;
  void set_battery_fuel_gauge_millivolts(::google::protobuf::uint32 value);

  // optional uint32 battery_adc_millivolts = 3;
  bool has_battery_adc_millivolts() const;
  void clear_battery_adc_millivolts();
  static const int kBatteryAdcMillivoltsFieldNumber = 3;
  ::google::protobuf::uint32 battery_adc_millivolts() const;
  void set_battery_adc_millivolts(::google::protobuf::uint32 value);

  // optional sint32 temperature_celsius = 4;
  bool has_temperature_celsius() const;
  void clear_temperature_celsius();
  static const int kTemperatureCelsiusFieldNumber = 4;
  ::google::protobuf::int32 temperature_celsius() const;
  void set_temperature_celsius(::google::protobuf::int32 value);

  static const int kMuseDataFieldNumber = 101;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::Battery >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.Battery)
 private:
  inline void set_has_percent_remaining();
  inline void clear_has_percent_remaining();
  inline void set_has_battery_fuel_gauge_millivolts();
  inline void clear_has_battery_fuel_gauge_millivolts();
  inline void set_has_battery_adc_millivolts();
  inline void clear_has_battery_adc_millivolts();
  inline void set_has_temperature_celsius();
  inline void clear_has_temperature_celsius();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 percent_remaining_;
  ::google::protobuf::uint32 battery_fuel_gauge_millivolts_;
  ::google::protobuf::uint32 battery_adc_millivolts_;
  ::google::protobuf::int32 temperature_celsius_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static Battery* default_instance_;
};
// -------------------------------------------------------------------

class MuseVersion : public ::google::protobuf::MessageLite {
 public:
  MuseVersion();
  virtual ~MuseVersion();

  MuseVersion(const MuseVersion& from);

  inline MuseVersion& operator=(const MuseVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseVersion& default_instance();

  void Swap(MuseVersion* other);

  // implements Message ----------------------------------------------

  inline MuseVersion* New() const { return New(NULL); }

  MuseVersion* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseVersion& from);
  void MergeFrom(const MuseVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hardware_version = 1;
  bool has_hardware_version() const;
  void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 1;
  const ::std::string& hardware_version() const;
  void set_hardware_version(const ::std::string& value);
  void set_hardware_version(const char* value);
  void set_hardware_version(const char* value, size_t size);
  ::std::string* mutable_hardware_version();
  ::std::string* release_hardware_version();
  void set_allocated_hardware_version(::std::string* hardware_version);

  // optional string firmware_headset_version = 2;
  bool has_firmware_headset_version() const;
  void clear_firmware_headset_version();
  static const int kFirmwareHeadsetVersionFieldNumber = 2;
  const ::std::string& firmware_headset_version() const;
  void set_firmware_headset_version(const ::std::string& value);
  void set_firmware_headset_version(const char* value);
  void set_firmware_headset_version(const char* value, size_t size);
  ::std::string* mutable_firmware_headset_version();
  ::std::string* release_firmware_headset_version();
  void set_allocated_firmware_headset_version(::std::string* firmware_headset_version);

  // optional string firmware_type = 3;
  bool has_firmware_type() const;
  void clear_firmware_type();
  static const int kFirmwareTypeFieldNumber = 3;
  const ::std::string& firmware_type() const;
  void set_firmware_type(const ::std::string& value);
  void set_firmware_type(const char* value);
  void set_firmware_type(const char* value, size_t size);
  ::std::string* mutable_firmware_type();
  ::std::string* release_firmware_type();
  void set_allocated_firmware_type(::std::string* firmware_type);

  // optional string firmware_bootloader_version = 4;
  bool has_firmware_bootloader_version() const;
  void clear_firmware_bootloader_version();
  static const int kFirmwareBootloaderVersionFieldNumber = 4;
  const ::std::string& firmware_bootloader_version() const;
  void set_firmware_bootloader_version(const ::std::string& value);
  void set_firmware_bootloader_version(const char* value);
  void set_firmware_bootloader_version(const char* value, size_t size);
  ::std::string* mutable_firmware_bootloader_version();
  ::std::string* release_firmware_bootloader_version();
  void set_allocated_firmware_bootloader_version(::std::string* firmware_bootloader_version);

  // optional string build_number = 5;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 5;
  const ::std::string& build_number() const;
  void set_build_number(const ::std::string& value);
  void set_build_number(const char* value);
  void set_build_number(const char* value, size_t size);
  ::std::string* mutable_build_number();
  ::std::string* release_build_number();
  void set_allocated_build_number(::std::string* build_number);

  // optional string protocol_version = 6;
  bool has_protocol_version() const;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 6;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // optional string bsp_version = 7;
  bool has_bsp_version() const;
  void clear_bsp_version();
  static const int kBspVersionFieldNumber = 7;
  const ::std::string& bsp_version() const;
  void set_bsp_version(const ::std::string& value);
  void set_bsp_version(const char* value);
  void set_bsp_version(const char* value, size_t size);
  ::std::string* mutable_bsp_version();
  ::std::string* release_bsp_version();
  void set_allocated_bsp_version(::std::string* bsp_version);

  static const int kMuseDataFieldNumber = 102;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseVersion >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseVersion)
 private:
  inline void set_has_hardware_version();
  inline void clear_has_hardware_version();
  inline void set_has_firmware_headset_version();
  inline void clear_has_firmware_headset_version();
  inline void set_has_firmware_type();
  inline void clear_has_firmware_type();
  inline void set_has_firmware_bootloader_version();
  inline void clear_has_firmware_bootloader_version();
  inline void set_has_build_number();
  inline void clear_has_build_number();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_bsp_version();
  inline void clear_has_bsp_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hardware_version_;
  ::google::protobuf::internal::ArenaStringPtr firmware_headset_version_;
  ::google::protobuf::internal::ArenaStringPtr firmware_type_;
  ::google::protobuf::internal::ArenaStringPtr firmware_bootloader_version_;
  ::google::protobuf::internal::ArenaStringPtr build_number_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::google::protobuf::internal::ArenaStringPtr bsp_version_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseVersion* default_instance_;
};
// -------------------------------------------------------------------

class MuseConfig : public ::google::protobuf::MessageLite {
 public:
  MuseConfig();
  virtual ~MuseConfig();

  MuseConfig(const MuseConfig& from);

  inline MuseConfig& operator=(const MuseConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseConfig& default_instance();

  void Swap(MuseConfig* other);

  // implements Message ----------------------------------------------

  inline MuseConfig* New() const { return New(NULL); }

  MuseConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseConfig& from);
  void MergeFrom(const MuseConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MuseConfig_MuseModel MuseModel;
  static const MuseModel MU_01 = MuseConfig_MuseModel_MU_01;
  static const MuseModel MU_02 = MuseConfig_MuseModel_MU_02;
  static inline bool MuseModel_IsValid(int value) {
    return MuseConfig_MuseModel_IsValid(value);
  }
  static const MuseModel MuseModel_MIN =
    MuseConfig_MuseModel_MuseModel_MIN;
  static const MuseModel MuseModel_MAX =
    MuseConfig_MuseModel_MuseModel_MAX;
  static const int MuseModel_ARRAYSIZE =
    MuseConfig_MuseModel_MuseModel_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string mac_addr = 1;
  bool has_mac_addr() const;
  void clear_mac_addr();
  static const int kMacAddrFieldNumber = 1;
  const ::std::string& mac_addr() const;
  void set_mac_addr(const ::std::string& value);
  void set_mac_addr(const char* value);
  void set_mac_addr(const char* value, size_t size);
  ::std::string* mutable_mac_addr();
  ::std::string* release_mac_addr();
  void set_allocated_mac_addr(::std::string* mac_addr);

  // optional string serial_number = 2;
  bool has_serial_number() const;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // optional string preset = 3;
  bool has_preset() const;
  void clear_preset();
  static const int kPresetFieldNumber = 3;
  const ::std::string& preset() const;
  void set_preset(const ::std::string& value);
  void set_preset(const char* value);
  void set_preset(const char* value, size_t size);
  ::std::string* mutable_preset();
  ::std::string* release_preset();
  void set_allocated_preset(::std::string* preset);

  // optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 4;
  ::interaxon::muse_data::MuseConfig_MuseModel model() const;
  void set_model(::interaxon::muse_data::MuseConfig_MuseModel value);

  // optional string headband_name = 5;
  bool has_headband_name() const;
  void clear_headband_name();
  static const int kHeadbandNameFieldNumber = 5;
  const ::std::string& headband_name() const;
  void set_headband_name(const ::std::string& value);
  void set_headband_name(const char* value);
  void set_headband_name(const char* value, size_t size);
  ::std::string* mutable_headband_name();
  ::std::string* release_headband_name();
  void set_allocated_headband_name(::std::string* headband_name);

  // optional string microcontroller_id = 6;
  bool has_microcontroller_id() const;
  void clear_microcontroller_id();
  static const int kMicrocontrollerIdFieldNumber = 6;
  const ::std::string& microcontroller_id() const;
  void set_microcontroller_id(const ::std::string& value);
  void set_microcontroller_id(const char* value);
  void set_microcontroller_id(const char* value, size_t size);
  ::std::string* mutable_microcontroller_id();
  ::std::string* release_microcontroller_id();
  void set_allocated_microcontroller_id(::std::string* microcontroller_id);

  // optional bool compression_enabled = 100;
  bool has_compression_enabled() const;
  void clear_compression_enabled();
  static const int kCompressionEnabledFieldNumber = 100;
  bool compression_enabled() const;
  void set_compression_enabled(bool value);

  // optional bool filters_enabled = 201;
  bool has_filters_enabled() const;
  void clear_filters_enabled();
  static const int kFiltersEnabledFieldNumber = 201;
  bool filters_enabled() const;
  void set_filters_enabled(bool value);

  // optional uint32 notch_frequency_hz = 202;
  bool has_notch_frequency_hz() const;
  void clear_notch_frequency_hz();
  static const int kNotchFrequencyHzFieldNumber = 202;
  ::google::protobuf::uint32 notch_frequency_hz() const;
  void set_notch_frequency_hz(::google::protobuf::uint32 value);

  // optional uint32 eeg_sample_frequency_hz = 203;
  bool has_eeg_sample_frequency_hz() const;
  void clear_eeg_sample_frequency_hz();
  static const int kEegSampleFrequencyHzFieldNumber = 203;
  ::google::protobuf::uint32 eeg_sample_frequency_hz() const;
  void set_eeg_sample_frequency_hz(::google::protobuf::uint32 value);

  // optional uint32 eeg_output_frequency_hz = 204;
  bool has_eeg_output_frequency_hz() const;
  void clear_eeg_output_frequency_hz();
  static const int kEegOutputFrequencyHzFieldNumber = 204;
  ::google::protobuf::uint32 eeg_output_frequency_hz() const;
  void set_eeg_output_frequency_hz(::google::protobuf::uint32 value);

  // optional uint32 eeg_samples_bitwidth = 205;
  bool has_eeg_samples_bitwidth() const;
  void clear_eeg_samples_bitwidth();
  static const int kEegSamplesBitwidthFieldNumber = 205;
  ::google::protobuf::uint32 eeg_samples_bitwidth() const;
  void set_eeg_samples_bitwidth(::google::protobuf::uint32 value);

  // optional uint32 eeg_channel_count = 206;
  bool has_eeg_channel_count() const;
  void clear_eeg_channel_count();
  static const int kEegChannelCountFieldNumber = 206;
  ::google::protobuf::uint32 eeg_channel_count() const;
  void set_eeg_channel_count(::google::protobuf::uint32 value);

  // optional string eeg_channel_layout = 207;
  bool has_eeg_channel_layout() const;
  void clear_eeg_channel_layout();
  static const int kEegChannelLayoutFieldNumber = 207;
  const ::std::string& eeg_channel_layout() const;
  void set_eeg_channel_layout(const ::std::string& value);
  void set_eeg_channel_layout(const char* value);
  void set_eeg_channel_layout(const char* value, size_t size);
  ::std::string* mutable_eeg_channel_layout();
  ::std::string* release_eeg_channel_layout();
  void set_allocated_eeg_channel_layout(::std::string* eeg_channel_layout);

  // optional uint32 eeg_downsample = 208;
  bool has_eeg_downsample() const;
  void clear_eeg_downsample();
  static const int kEegDownsampleFieldNumber = 208;
  ::google::protobuf::uint32 eeg_downsample() const;
  void set_eeg_downsample(::google::protobuf::uint32 value);

  // optional .interaxon.muse_data.EEGUnits eeg_units = 209;
  bool has_eeg_units() const;
  void clear_eeg_units();
  static const int kEegUnitsFieldNumber = 209;
  ::interaxon::muse_data::EEGUnits eeg_units() const;
  void set_eeg_units(::interaxon::muse_data::EEGUnits value);

  // repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
  int eeg_locations_size() const;
  void clear_eeg_locations();
  static const int kEegLocationsFieldNumber = 210;
  ::interaxon::muse_data::HeadLocations eeg_locations(int index) const;
  void set_eeg_locations(int index, ::interaxon::muse_data::HeadLocations value);
  void add_eeg_locations(::interaxon::muse_data::HeadLocations value);
  const ::google::protobuf::RepeatedField<int>& eeg_locations() const;
  ::google::protobuf::RepeatedField<int>* mutable_eeg_locations();

  // optional float eeg_conversion_factor = 211;
  bool has_eeg_conversion_factor() const;
  void clear_eeg_conversion_factor();
  static const int kEegConversionFactorFieldNumber = 211;
  float eeg_conversion_factor() const;
  void set_eeg_conversion_factor(float value);

  // optional float afe_gain = 212;
  bool has_afe_gain() const;
  void clear_afe_gain();
  static const int kAfeGainFieldNumber = 212;
  float afe_gain() const;
  void set_afe_gain(float value);

  // optional bool drlref_data_enabled = 300;
  bool has_drlref_data_enabled() const;
  void clear_drlref_data_enabled();
  static const int kDrlrefDataEnabledFieldNumber = 300;
  bool drlref_data_enabled() const;
  void set_drlref_data_enabled(bool value);

  // optional float drlref_conversion_factor = 301;
  bool has_drlref_conversion_factor() const;
  void clear_drlref_conversion_factor();
  static const int kDrlrefConversionFactorFieldNumber = 301;
  float drlref_conversion_factor() const;
  void set_drlref_conversion_factor(float value);

  // optional uint32 drlref_sample_frequency_hz = 302;
  bool has_drlref_sample_frequency_hz() const;
  void clear_drlref_sample_frequency_hz();
  static const int kDrlrefSampleFrequencyHzFieldNumber = 302;
  ::google::protobuf::uint32 drlref_sample_frequency_hz() const;
  void set_drlref_sample_frequency_hz(::google::protobuf::uint32 value);

  // optional bool acc_data_enabled = 400;
  bool has_acc_data_enabled() const;
  void clear_acc_data_enabled();
  static const int kAccDataEnabledFieldNumber = 400;
  bool acc_data_enabled() const;
  void set_acc_data_enabled(bool value);

  // optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
  bool has_acc_units() const;
  void clear_acc_units();
  static const int kAccUnitsFieldNumber = 401;
  ::interaxon::muse_data::AccelerometerUnits acc_units() const;
  void set_acc_units(::interaxon::muse_data::AccelerometerUnits value);

  // optional float acc_conversion_factor = 402;
  bool has_acc_conversion_factor() const;
  void clear_acc_conversion_factor();
  static const int kAccConversionFactorFieldNumber = 402;
  float acc_conversion_factor() const;
  void set_acc_conversion_factor(float value);

  // optional uint32 acc_sample_frequency_hz = 403;
  bool has_acc_sample_frequency_hz() const;
  void clear_acc_sample_frequency_hz();
  static const int kAccSampleFrequencyHzFieldNumber = 403;
  ::google::protobuf::uint32 acc_sample_frequency_hz() const;
  void set_acc_sample_frequency_hz(::google::protobuf::uint32 value);

  // optional bool battery_data_enabled = 500;
  bool has_battery_data_enabled() const;
  void clear_battery_data_enabled();
  static const int kBatteryDataEnabledFieldNumber = 500;
  bool battery_data_enabled() const;
  void set_battery_data_enabled(bool value);

  // optional uint32 battery_percent_remaining = 501;
  bool has_battery_percent_remaining() const;
  void clear_battery_percent_remaining();
  static const int kBatteryPercentRemainingFieldNumber = 501;
  ::google::protobuf::uint32 battery_percent_remaining() const;
  void set_battery_percent_remaining(::google::protobuf::uint32 value);

  // optional uint32 battery_millivolts = 502;
  bool has_battery_millivolts() const;
  void clear_battery_millivolts();
  static const int kBatteryMillivoltsFieldNumber = 502;
  ::google::protobuf::uint32 battery_millivolts() const;
  void set_battery_millivolts(::google::protobuf::uint32 value);

  // optional bool error_data_enabled = 600;
  bool has_error_data_enabled() const;
  void clear_error_data_enabled();
  static const int kErrorDataEnabledFieldNumber = 600;
  bool error_data_enabled() const;
  void set_error_data_enabled(bool value);

  // optional bool gyro_data_enabled = 700;
  bool has_gyro_data_enabled() const;
  void clear_gyro_data_enabled();
  static const int kGyroDataEnabledFieldNumber = 700;
  bool gyro_data_enabled() const;
  void set_gyro_data_enabled(bool value);

  // optional float gyro_conversion_factor = 702;
  bool has_gyro_conversion_factor() const;
  void clear_gyro_conversion_factor();
  static const int kGyroConversionFactorFieldNumber = 702;
  float gyro_conversion_factor() const;
  void set_gyro_conversion_factor(float value);

  // optional uint32 gyro_sample_frequency = 703;
  bool has_gyro_sample_frequency() const;
  void clear_gyro_sample_frequency();
  static const int kGyroSampleFrequencyFieldNumber = 703;
  ::google::protobuf::uint32 gyro_sample_frequency() const;
  void set_gyro_sample_frequency(::google::protobuf::uint32 value);

  static const int kMuseDataFieldNumber = 103;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseConfig >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseConfig)
 private:
  inline void set_has_mac_addr();
  inline void clear_has_mac_addr();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_preset();
  inline void clear_has_preset();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_headband_name();
  inline void clear_has_headband_name();
  inline void set_has_microcontroller_id();
  inline void clear_has_microcontroller_id();
  inline void set_has_compression_enabled();
  inline void clear_has_compression_enabled();
  inline void set_has_filters_enabled();
  inline void clear_has_filters_enabled();
  inline void set_has_notch_frequency_hz();
  inline void clear_has_notch_frequency_hz();
  inline void set_has_eeg_sample_frequency_hz();
  inline void clear_has_eeg_sample_frequency_hz();
  inline void set_has_eeg_output_frequency_hz();
  inline void clear_has_eeg_output_frequency_hz();
  inline void set_has_eeg_samples_bitwidth();
  inline void clear_has_eeg_samples_bitwidth();
  inline void set_has_eeg_channel_count();
  inline void clear_has_eeg_channel_count();
  inline void set_has_eeg_channel_layout();
  inline void clear_has_eeg_channel_layout();
  inline void set_has_eeg_downsample();
  inline void clear_has_eeg_downsample();
  inline void set_has_eeg_units();
  inline void clear_has_eeg_units();
  inline void set_has_eeg_conversion_factor();
  inline void clear_has_eeg_conversion_factor();
  inline void set_has_afe_gain();
  inline void clear_has_afe_gain();
  inline void set_has_drlref_data_enabled();
  inline void clear_has_drlref_data_enabled();
  inline void set_has_drlref_conversion_factor();
  inline void clear_has_drlref_conversion_factor();
  inline void set_has_drlref_sample_frequency_hz();
  inline void clear_has_drlref_sample_frequency_hz();
  inline void set_has_acc_data_enabled();
  inline void clear_has_acc_data_enabled();
  inline void set_has_acc_units();
  inline void clear_has_acc_units();
  inline void set_has_acc_conversion_factor();
  inline void clear_has_acc_conversion_factor();
  inline void set_has_acc_sample_frequency_hz();
  inline void clear_has_acc_sample_frequency_hz();
  inline void set_has_battery_data_enabled();
  inline void clear_has_battery_data_enabled();
  inline void set_has_battery_percent_remaining();
  inline void clear_has_battery_percent_remaining();
  inline void set_has_battery_millivolts();
  inline void clear_has_battery_millivolts();
  inline void set_has_error_data_enabled();
  inline void clear_has_error_data_enabled();
  inline void set_has_gyro_data_enabled();
  inline void clear_has_gyro_data_enabled();
  inline void set_has_gyro_conversion_factor();
  inline void clear_has_gyro_conversion_factor();
  inline void set_has_gyro_sample_frequency();
  inline void clear_has_gyro_sample_frequency();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::google::protobuf::internal::ArenaStringPtr mac_addr_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr preset_;
  ::google::protobuf::internal::ArenaStringPtr headband_name_;
  ::google::protobuf::internal::ArenaStringPtr microcontroller_id_;
  int model_;
  ::google::protobuf::uint32 notch_frequency_hz_;
  ::google::protobuf::uint32 eeg_sample_frequency_hz_;
  ::google::protobuf::uint32 eeg_output_frequency_hz_;
  ::google::protobuf::uint32 eeg_samples_bitwidth_;
  ::google::protobuf::uint32 eeg_channel_count_;
  ::google::protobuf::internal::ArenaStringPtr eeg_channel_layout_;
  bool compression_enabled_;
  bool filters_enabled_;
  bool drlref_data_enabled_;
  bool acc_data_enabled_;
  ::google::protobuf::uint32 eeg_downsample_;
  ::google::protobuf::RepeatedField<int> eeg_locations_;
  int eeg_units_;
  float eeg_conversion_factor_;
  float afe_gain_;
  float drlref_conversion_factor_;
  ::google::protobuf::uint32 drlref_sample_frequency_hz_;
  int acc_units_;
  float acc_conversion_factor_;
  ::google::protobuf::uint32 acc_sample_frequency_hz_;
  ::google::protobuf::uint32 battery_percent_remaining_;
  ::google::protobuf::uint32 battery_millivolts_;
  bool battery_data_enabled_;
  bool error_data_enabled_;
  bool gyro_data_enabled_;
  float gyro_conversion_factor_;
  ::google::protobuf::uint32 gyro_sample_frequency_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseConfig* default_instance_;
};
// -------------------------------------------------------------------

class EEG_DroppedSamples : public ::google::protobuf::MessageLite {
 public:
  EEG_DroppedSamples();
  virtual ~EEG_DroppedSamples();

  EEG_DroppedSamples(const EEG_DroppedSamples& from);

  inline EEG_DroppedSamples& operator=(const EEG_DroppedSamples& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EEG_DroppedSamples& default_instance();

  void Swap(EEG_DroppedSamples* other);

  // implements Message ----------------------------------------------

  inline EEG_DroppedSamples* New() const { return New(NULL); }

  EEG_DroppedSamples* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EEG_DroppedSamples& from);
  void MergeFrom(const EEG_DroppedSamples& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EEG_DroppedSamples* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::uint32 num() const;
  void set_num(::google::protobuf::uint32 value);

  static const int kMuseDataFieldNumber = 202;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::EEG_DroppedSamples >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.EEG_DroppedSamples)
 private:
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static EEG_DroppedSamples* default_instance_;
};
// -------------------------------------------------------------------

class ACC_DroppedSamples : public ::google::protobuf::MessageLite {
 public:
  ACC_DroppedSamples();
  virtual ~ACC_DroppedSamples();

  ACC_DroppedSamples(const ACC_DroppedSamples& from);

  inline ACC_DroppedSamples& operator=(const ACC_DroppedSamples& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ACC_DroppedSamples& default_instance();

  void Swap(ACC_DroppedSamples* other);

  // implements Message ----------------------------------------------

  inline ACC_DroppedSamples* New() const { return New(NULL); }

  ACC_DroppedSamples* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACC_DroppedSamples& from);
  void MergeFrom(const ACC_DroppedSamples& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ACC_DroppedSamples* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::uint32 num() const;
  void set_num(::google::protobuf::uint32 value);

  static const int kMuseDataFieldNumber = 203;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::ACC_DroppedSamples >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.ACC_DroppedSamples)
 private:
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static ACC_DroppedSamples* default_instance_;
};
// -------------------------------------------------------------------

class ComputingDevice : public ::google::protobuf::MessageLite {
 public:
  ComputingDevice();
  virtual ~ComputingDevice();

  ComputingDevice(const ComputingDevice& from);

  inline ComputingDevice& operator=(const ComputingDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ComputingDevice& default_instance();

  void Swap(ComputingDevice* other);

  // implements Message ----------------------------------------------

  inline ComputingDevice* New() const { return New(NULL); }

  ComputingDevice* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ComputingDevice& from);
  void MergeFrom(const ComputingDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputingDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os_type = 1;
  bool has_os_type() const;
  void clear_os_type();
  static const int kOsTypeFieldNumber = 1;
  const ::std::string& os_type() const;
  void set_os_type(const ::std::string& value);
  void set_os_type(const char* value);
  void set_os_type(const char* value, size_t size);
  ::std::string* mutable_os_type();
  ::std::string* release_os_type();
  void set_allocated_os_type(::std::string* os_type);

  // optional string os_version = 2;
  bool has_os_version() const;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // optional string hardware_model_name = 3;
  bool has_hardware_model_name() const;
  void clear_hardware_model_name();
  static const int kHardwareModelNameFieldNumber = 3;
  const ::std::string& hardware_model_name() const;
  void set_hardware_model_name(const ::std::string& value);
  void set_hardware_model_name(const char* value);
  void set_hardware_model_name(const char* value, size_t size);
  ::std::string* mutable_hardware_model_name();
  ::std::string* release_hardware_model_name();
  void set_allocated_hardware_model_name(::std::string* hardware_model_name);

  // optional string hardware_model_id = 4;
  bool has_hardware_model_id() const;
  void clear_hardware_model_id();
  static const int kHardwareModelIdFieldNumber = 4;
  const ::std::string& hardware_model_id() const;
  void set_hardware_model_id(const ::std::string& value);
  void set_hardware_model_id(const char* value);
  void set_hardware_model_id(const char* value, size_t size);
  ::std::string* mutable_hardware_model_id();
  ::std::string* release_hardware_model_id();
  void set_allocated_hardware_model_id(::std::string* hardware_model_id);

  // optional string processor_name = 5;
  bool has_processor_name() const;
  void clear_processor_name();
  static const int kProcessorNameFieldNumber = 5;
  const ::std::string& processor_name() const;
  void set_processor_name(const ::std::string& value);
  void set_processor_name(const char* value);
  void set_processor_name(const char* value, size_t size);
  ::std::string* mutable_processor_name();
  ::std::string* release_processor_name();
  void set_allocated_processor_name(::std::string* processor_name);

  // optional string processor_speed = 6;
  bool has_processor_speed() const;
  void clear_processor_speed();
  static const int kProcessorSpeedFieldNumber = 6;
  const ::std::string& processor_speed() const;
  void set_processor_speed(const ::std::string& value);
  void set_processor_speed(const char* value);
  void set_processor_speed(const char* value, size_t size);
  ::std::string* mutable_processor_speed();
  ::std::string* release_processor_speed();
  void set_allocated_processor_speed(::std::string* processor_speed);

  // optional uint32 number_of_processors = 7;
  bool has_number_of_processors() const;
  void clear_number_of_processors();
  static const int kNumberOfProcessorsFieldNumber = 7;
  ::google::protobuf::uint32 number_of_processors() const;
  void set_number_of_processors(::google::protobuf::uint32 value);

  // optional string memory_size = 8;
  bool has_memory_size() const;
  void clear_memory_size();
  static const int kMemorySizeFieldNumber = 8;
  const ::std::string& memory_size() const;
  void set_memory_size(const ::std::string& value);
  void set_memory_size(const char* value);
  void set_memory_size(const char* value, size_t size);
  ::std::string* mutable_memory_size();
  ::std::string* release_memory_size();
  void set_allocated_memory_size(::std::string* memory_size);

  // optional string bluetooth_version = 9;
  bool has_bluetooth_version() const;
  void clear_bluetooth_version();
  static const int kBluetoothVersionFieldNumber = 9;
  const ::std::string& bluetooth_version() const;
  void set_bluetooth_version(const ::std::string& value);
  void set_bluetooth_version(const char* value);
  void set_bluetooth_version(const char* value, size_t size);
  ::std::string* mutable_bluetooth_version();
  ::std::string* release_bluetooth_version();
  void set_allocated_bluetooth_version(::std::string* bluetooth_version);

  // optional string time_zone = 10;
  bool has_time_zone() const;
  void clear_time_zone();
  static const int kTimeZoneFieldNumber = 10;
  const ::std::string& time_zone() const;
  void set_time_zone(const ::std::string& value);
  void set_time_zone(const char* value);
  void set_time_zone(const char* value, size_t size);
  ::std::string* mutable_time_zone();
  ::std::string* release_time_zone();
  void set_allocated_time_zone(::std::string* time_zone);

  // optional sint32 time_zone_offset_seconds = 11;
  bool has_time_zone_offset_seconds() const;
  void clear_time_zone_offset_seconds();
  static const int kTimeZoneOffsetSecondsFieldNumber = 11;
  ::google::protobuf::int32 time_zone_offset_seconds() const;
  void set_time_zone_offset_seconds(::google::protobuf::int32 value);

  static const int kMuseDataFieldNumber = 201;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::ComputingDevice >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.ComputingDevice)
 private:
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_hardware_model_name();
  inline void clear_has_hardware_model_name();
  inline void set_has_hardware_model_id();
  inline void clear_has_hardware_model_id();
  inline void set_has_processor_name();
  inline void clear_has_processor_name();
  inline void set_has_processor_speed();
  inline void clear_has_processor_speed();
  inline void set_has_number_of_processors();
  inline void clear_has_number_of_processors();
  inline void set_has_memory_size();
  inline void clear_has_memory_size();
  inline void set_has_bluetooth_version();
  inline void clear_has_bluetooth_version();
  inline void set_has_time_zone();
  inline void clear_has_time_zone();
  inline void set_has_time_zone_offset_seconds();
  inline void clear_has_time_zone_offset_seconds();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr os_type_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::internal::ArenaStringPtr hardware_model_name_;
  ::google::protobuf::internal::ArenaStringPtr hardware_model_id_;
  ::google::protobuf::internal::ArenaStringPtr processor_name_;
  ::google::protobuf::internal::ArenaStringPtr processor_speed_;
  ::google::protobuf::internal::ArenaStringPtr memory_size_;
  ::google::protobuf::internal::ArenaStringPtr bluetooth_version_;
  ::google::protobuf::uint32 number_of_processors_;
  ::google::protobuf::int32 time_zone_offset_seconds_;
  ::google::protobuf::internal::ArenaStringPtr time_zone_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static ComputingDevice* default_instance_;
};
// -------------------------------------------------------------------

class DSP : public ::google::protobuf::MessageLite {
 public:
  DSP();
  virtual ~DSP();

  DSP(const DSP& from);

  inline DSP& operator=(const DSP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DSP& default_instance();

  void Swap(DSP* other);

  // implements Message ----------------------------------------------

  inline DSP* New() const { return New(NULL); }

  DSP* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DSP& from);
  void MergeFrom(const DSP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DSP* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // repeated float float_array = 2;
  int float_array_size() const;
  void clear_float_array();
  static const int kFloatArrayFieldNumber = 2;
  float float_array(int index) const;
  void set_float_array(int index, float value);
  void add_float_array(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_array() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_array();

  // repeated uint32 int_array = 3;
  int int_array_size() const;
  void clear_int_array();
  static const int kIntArrayFieldNumber = 3;
  ::google::protobuf::uint32 int_array(int index) const;
  void set_int_array(int index, ::google::protobuf::uint32 value);
  void add_int_array(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      int_array() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_int_array();

  // optional string version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  static const int kMuseDataFieldNumber = 200;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::DSP >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.DSP)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::RepeatedField< float > float_array_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > int_array_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static DSP* default_instance_;
};
// -------------------------------------------------------------------

class MuseElement : public ::google::protobuf::MessageLite {
 public:
  MuseElement();
  virtual ~MuseElement();

  MuseElement(const MuseElement& from);

  inline MuseElement& operator=(const MuseElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const MuseElement& default_instance();

  void Swap(MuseElement* other);

  // implements Message ----------------------------------------------

  inline MuseElement* New() const { return New(NULL); }

  MuseElement* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MuseElement& from);
  void MergeFrom(const MuseElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MuseElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .interaxon.muse_data.MuseElementType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::interaxon::muse_data::MuseElementType type() const;
  void set_type(::interaxon::muse_data::MuseElementType value);

  // optional string string_type = 2;
  bool has_string_type() const;
  void clear_string_type();
  static const int kStringTypeFieldNumber = 2;
  const ::std::string& string_type() const;
  void set_string_type(const ::std::string& value);
  void set_string_type(const char* value);
  void set_string_type(const char* value, size_t size);
  ::std::string* mutable_string_type();
  ::std::string* release_string_type();
  void set_allocated_string_type(::std::string* string_type);

  // optional uint32 algorithm_version = 3;
  bool has_algorithm_version() const;
  void clear_algorithm_version();
  static const int kAlgorithmVersionFieldNumber = 3;
  ::google::protobuf::uint32 algorithm_version() const;
  void set_algorithm_version(::google::protobuf::uint32 value);

  // repeated double real_array = 4;
  int real_array_size() const;
  void clear_real_array();
  static const int kRealArrayFieldNumber = 4;
  double real_array(int index) const;
  void set_real_array(int index, double value);
  void add_real_array(double value);
  const ::google::protobuf::RepeatedField< double >&
      real_array() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_real_array();

  // repeated uint32 integer_array = 5;
  int integer_array_size() const;
  void clear_integer_array();
  static const int kIntegerArrayFieldNumber = 5;
  ::google::protobuf::uint32 integer_array(int index) const;
  void set_integer_array(int index, ::google::protobuf::uint32 value);
  void add_integer_array(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      integer_array() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_integer_array();

  static const int kMuseDataFieldNumber = 204;
  static ::google::protobuf::internal::ExtensionIdentifier< ::interaxon::muse_data::MuseData,
      ::google::protobuf::internal::MessageTypeTraits< ::interaxon::muse_data::MuseElement >, 11, false >
    museData;
  // @@protoc_insertion_point(class_scope:interaxon.muse_data.MuseElement)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_string_type();
  inline void clear_has_string_type();
  inline void set_has_algorithm_version();
  inline void clear_has_algorithm_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr string_type_;
  int type_;
  ::google::protobuf::uint32 algorithm_version_;
  ::google::protobuf::RepeatedField< double > real_array_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > integer_array_;
  friend void  protobuf_AddDesc_Muse_5fv2_2eproto();
  friend void protobuf_AssignDesc_Muse_5fv2_2eproto();
  friend void protobuf_ShutdownFile_Muse_5fv2_2eproto();

  void InitAsDefaultInstance();
  static MuseElement* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MuseDataCollection

// repeated .interaxon.muse_data.MuseData collection = 1;
inline int MuseDataCollection::collection_size() const {
  return collection_.size();
}
inline void MuseDataCollection::clear_collection() {
  collection_.Clear();
}
inline const ::interaxon::muse_data::MuseData& MuseDataCollection::collection(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Get(index);
}
inline ::interaxon::muse_data::MuseData* MuseDataCollection::mutable_collection(int index) {
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Mutable(index);
}
inline ::interaxon::muse_data::MuseData* MuseDataCollection::add_collection() {
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseDataCollection.collection)
  return collection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >*
MuseDataCollection::mutable_collection() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseDataCollection.collection)
  return &collection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::interaxon::muse_data::MuseData >&
MuseDataCollection::collection() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseDataCollection.collection)
  return collection_;
}

// -------------------------------------------------------------------

// MuseData

// required double timestamp = 1;
inline bool MuseData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MuseData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MuseData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MuseData::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double MuseData::timestamp() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.timestamp)
  return timestamp_;
}
inline void MuseData::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.timestamp)
}

// required .interaxon.muse_data.MuseData.Datatype datatype = 2;
inline bool MuseData::has_datatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MuseData::set_has_datatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MuseData::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MuseData::clear_datatype() {
  datatype_ = 0;
  clear_has_datatype();
}
inline ::interaxon::muse_data::MuseData_Datatype MuseData::datatype() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.datatype)
  return static_cast< ::interaxon::muse_data::MuseData_Datatype >(datatype_);
}
inline void MuseData::set_datatype(::interaxon::muse_data::MuseData_Datatype value) {
  assert(::interaxon::muse_data::MuseData_Datatype_IsValid(value));
  set_has_datatype();
  datatype_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.datatype)
}

// optional uint64 config_id = 3;
inline bool MuseData::has_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MuseData::set_has_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MuseData::clear_has_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MuseData::clear_config_id() {
  config_id_ = GOOGLE_ULONGLONG(0);
  clear_has_config_id();
}
inline ::google::protobuf::uint64 MuseData::config_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseData.config_id)
  return config_id_;
}
inline void MuseData::set_config_id(::google::protobuf::uint64 value) {
  set_has_config_id();
  config_id_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseData.config_id)
}

// -------------------------------------------------------------------

// EEG

// repeated float values = 2;
inline int EEG::values_size() const {
  return values_.size();
}
inline void EEG::clear_values() {
  values_.Clear();
}
inline float EEG::values(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.values)
  return values_.Get(index);
}
inline void EEG::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.values)
}
inline void EEG::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.EEG.values)
}
inline const ::google::protobuf::RepeatedField< float >&
EEG::values() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.EEG.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
EEG::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.EEG.values)
  return &values_;
}

// optional float drl = 5;
inline bool EEG::has_drl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EEG::set_has_drl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EEG::clear_has_drl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EEG::clear_drl() {
  drl_ = 0;
  clear_has_drl();
}
inline float EEG::drl() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.drl)
  return drl_;
}
inline void EEG::set_drl(float value) {
  set_has_drl();
  drl_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.drl)
}

// optional float ref = 6;
inline bool EEG::has_ref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EEG::set_has_ref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EEG::clear_has_ref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EEG::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline float EEG::ref() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG.ref)
  return ref_;
}
inline void EEG::set_ref(float value) {
  set_has_ref();
  ref_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG.ref)
}

// -------------------------------------------------------------------

// MuseQuantization

// repeated uint32 values = 1;
inline int MuseQuantization::values_size() const {
  return values_.size();
}
inline void MuseQuantization::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 MuseQuantization::values(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseQuantization.values)
  return values_.Get(index);
}
inline void MuseQuantization::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseQuantization.values)
}
inline void MuseQuantization::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseQuantization.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MuseQuantization::values() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseQuantization.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MuseQuantization::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseQuantization.values)
  return &values_;
}

// -------------------------------------------------------------------

// Accelerometer

// optional float acc1 = 1;
inline bool Accelerometer::has_acc1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Accelerometer::set_has_acc1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Accelerometer::clear_has_acc1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Accelerometer::clear_acc1() {
  acc1_ = 0;
  clear_has_acc1();
}
inline float Accelerometer::acc1() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc1)
  return acc1_;
}
inline void Accelerometer::set_acc1(float value) {
  set_has_acc1();
  acc1_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc1)
}

// optional float acc2 = 2;
inline bool Accelerometer::has_acc2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Accelerometer::set_has_acc2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Accelerometer::clear_has_acc2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Accelerometer::clear_acc2() {
  acc2_ = 0;
  clear_has_acc2();
}
inline float Accelerometer::acc2() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc2)
  return acc2_;
}
inline void Accelerometer::set_acc2(float value) {
  set_has_acc2();
  acc2_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc2)
}

// optional float acc3 = 3;
inline bool Accelerometer::has_acc3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Accelerometer::set_has_acc3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Accelerometer::clear_has_acc3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Accelerometer::clear_acc3() {
  acc3_ = 0;
  clear_has_acc3();
}
inline float Accelerometer::acc3() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Accelerometer.acc3)
  return acc3_;
}
inline void Accelerometer::set_acc3(float value) {
  set_has_acc3();
  acc3_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Accelerometer.acc3)
}

// -------------------------------------------------------------------

// Gyro

// optional float gyro1 = 1;
inline bool Gyro::has_gyro1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gyro::set_has_gyro1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gyro::clear_has_gyro1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gyro::clear_gyro1() {
  gyro1_ = 0;
  clear_has_gyro1();
}
inline float Gyro::gyro1() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro1)
  return gyro1_;
}
inline void Gyro::set_gyro1(float value) {
  set_has_gyro1();
  gyro1_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro1)
}

// optional float gyro2 = 2;
inline bool Gyro::has_gyro2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gyro::set_has_gyro2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gyro::clear_has_gyro2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gyro::clear_gyro2() {
  gyro2_ = 0;
  clear_has_gyro2();
}
inline float Gyro::gyro2() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro2)
  return gyro2_;
}
inline void Gyro::set_gyro2(float value) {
  set_has_gyro2();
  gyro2_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro2)
}

// optional float gyro3 = 3;
inline bool Gyro::has_gyro3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gyro::set_has_gyro3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gyro::clear_has_gyro3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gyro::clear_gyro3() {
  gyro3_ = 0;
  clear_has_gyro3();
}
inline float Gyro::gyro3() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Gyro.gyro3)
  return gyro3_;
}
inline void Gyro::set_gyro3(float value) {
  set_has_gyro3();
  gyro3_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Gyro.gyro3)
}

// -------------------------------------------------------------------

// Annotation

// optional string event_data = 1;
inline bool Annotation::has_event_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Annotation::set_has_event_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Annotation::clear_has_event_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Annotation::clear_event_data() {
  event_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_data();
}
inline const ::std::string& Annotation::event_data() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_data)
  return event_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_event_data(const ::std::string& value) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_data)
}
inline void Annotation::set_event_data(const char* value) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_data)
}
inline void Annotation::set_event_data(const char* value, size_t size) {
  set_has_event_data();
  event_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_data)
}
inline ::std::string* Annotation::mutable_event_data() {
  set_has_event_data();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_data)
  return event_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_event_data() {
  clear_has_event_data();
  return event_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_event_data(::std::string* event_data) {
  if (event_data != NULL) {
    set_has_event_data();
  } else {
    clear_has_event_data();
  }
  event_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_data);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_data)
}

// optional .interaxon.muse_data.Annotation.Format event_data_format = 2 [default = PLAIN_STRING];
inline bool Annotation::has_event_data_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Annotation::set_has_event_data_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Annotation::clear_has_event_data_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Annotation::clear_event_data_format() {
  event_data_format_ = 0;
  clear_has_event_data_format();
}
inline ::interaxon::muse_data::Annotation_Format Annotation::event_data_format() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_data_format)
  return static_cast< ::interaxon::muse_data::Annotation_Format >(event_data_format_);
}
inline void Annotation::set_event_data_format(::interaxon::muse_data::Annotation_Format value) {
  assert(::interaxon::muse_data::Annotation_Format_IsValid(value));
  set_has_event_data_format();
  event_data_format_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_data_format)
}

// optional string event_type = 3;
inline bool Annotation::has_event_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Annotation::set_has_event_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Annotation::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Annotation::clear_event_type() {
  event_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_type();
}
inline const ::std::string& Annotation::event_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_type)
  return event_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_event_type(const ::std::string& value) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_type)
}
inline void Annotation::set_event_type(const char* value) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_type)
}
inline void Annotation::set_event_type(const char* value, size_t size) {
  set_has_event_type();
  event_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_type)
}
inline ::std::string* Annotation::mutable_event_type() {
  set_has_event_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_type)
  return event_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_event_type() {
  clear_has_event_type();
  return event_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_event_type(::std::string* event_type) {
  if (event_type != NULL) {
    set_has_event_type();
  } else {
    clear_has_event_type();
  }
  event_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_type)
}

// optional string event_id = 4;
inline bool Annotation::has_event_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Annotation::set_has_event_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Annotation::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Annotation::clear_event_id() {
  event_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_id();
}
inline const ::std::string& Annotation::event_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.event_id)
  return event_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_event_id(const ::std::string& value) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.event_id)
}
inline void Annotation::set_event_id(const char* value) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.event_id)
}
inline void Annotation::set_event_id(const char* value, size_t size) {
  set_has_event_id();
  event_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.event_id)
}
inline ::std::string* Annotation::mutable_event_id() {
  set_has_event_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.event_id)
  return event_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_event_id() {
  clear_has_event_id();
  return event_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_event_id(::std::string* event_id) {
  if (event_id != NULL) {
    set_has_event_id();
  } else {
    clear_has_event_id();
  }
  event_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.event_id)
}

// optional string parent_id = 5;
inline bool Annotation::has_parent_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Annotation::set_has_parent_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Annotation::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Annotation::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_id();
}
inline const ::std::string& Annotation::parent_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Annotation.parent_id)
  return parent_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_parent_id(const ::std::string& value) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Annotation.parent_id)
}
inline void Annotation::set_parent_id(const char* value) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.Annotation.parent_id)
}
inline void Annotation::set_parent_id(const char* value, size_t size) {
  set_has_parent_id();
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.Annotation.parent_id)
}
inline ::std::string* Annotation::mutable_parent_id() {
  set_has_parent_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.Annotation.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_parent_id() {
  clear_has_parent_id();
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    set_has_parent_id();
  } else {
    clear_has_parent_id();
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.Annotation.parent_id)
}

// -------------------------------------------------------------------

// Battery

// optional uint32 percent_remaining = 1;
inline bool Battery::has_percent_remaining() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Battery::set_has_percent_remaining() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Battery::clear_has_percent_remaining() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Battery::clear_percent_remaining() {
  percent_remaining_ = 0u;
  clear_has_percent_remaining();
}
inline ::google::protobuf::uint32 Battery::percent_remaining() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.percent_remaining)
  return percent_remaining_;
}
inline void Battery::set_percent_remaining(::google::protobuf::uint32 value) {
  set_has_percent_remaining();
  percent_remaining_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.percent_remaining)
}

// optional uint32 battery_fuel_gauge_millivolts = 2;
inline bool Battery::has_battery_fuel_gauge_millivolts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Battery::set_has_battery_fuel_gauge_millivolts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Battery::clear_has_battery_fuel_gauge_millivolts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Battery::clear_battery_fuel_gauge_millivolts() {
  battery_fuel_gauge_millivolts_ = 0u;
  clear_has_battery_fuel_gauge_millivolts();
}
inline ::google::protobuf::uint32 Battery::battery_fuel_gauge_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.battery_fuel_gauge_millivolts)
  return battery_fuel_gauge_millivolts_;
}
inline void Battery::set_battery_fuel_gauge_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_fuel_gauge_millivolts();
  battery_fuel_gauge_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.battery_fuel_gauge_millivolts)
}

// optional uint32 battery_adc_millivolts = 3;
inline bool Battery::has_battery_adc_millivolts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Battery::set_has_battery_adc_millivolts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Battery::clear_has_battery_adc_millivolts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Battery::clear_battery_adc_millivolts() {
  battery_adc_millivolts_ = 0u;
  clear_has_battery_adc_millivolts();
}
inline ::google::protobuf::uint32 Battery::battery_adc_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.battery_adc_millivolts)
  return battery_adc_millivolts_;
}
inline void Battery::set_battery_adc_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_adc_millivolts();
  battery_adc_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.battery_adc_millivolts)
}

// optional sint32 temperature_celsius = 4;
inline bool Battery::has_temperature_celsius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Battery::set_has_temperature_celsius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Battery::clear_has_temperature_celsius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Battery::clear_temperature_celsius() {
  temperature_celsius_ = 0;
  clear_has_temperature_celsius();
}
inline ::google::protobuf::int32 Battery::temperature_celsius() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.Battery.temperature_celsius)
  return temperature_celsius_;
}
inline void Battery::set_temperature_celsius(::google::protobuf::int32 value) {
  set_has_temperature_celsius();
  temperature_celsius_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.Battery.temperature_celsius)
}

// -------------------------------------------------------------------

// MuseVersion

// optional string hardware_version = 1;
inline bool MuseVersion::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MuseVersion::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MuseVersion::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MuseVersion::clear_hardware_version() {
  hardware_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_version();
}
inline const ::std::string& MuseVersion::hardware_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.hardware_version)
  return hardware_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.hardware_version)
}
inline void MuseVersion::set_hardware_version(const char* value) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.hardware_version)
}
inline void MuseVersion::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  hardware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.hardware_version)
}
inline ::std::string* MuseVersion::mutable_hardware_version() {
  set_has_hardware_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.hardware_version)
  return hardware_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_hardware_version() {
  clear_has_hardware_version();
  return hardware_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version != NULL) {
    set_has_hardware_version();
  } else {
    clear_has_hardware_version();
  }
  hardware_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.hardware_version)
}

// optional string firmware_headset_version = 2;
inline bool MuseVersion::has_firmware_headset_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MuseVersion::set_has_firmware_headset_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MuseVersion::clear_has_firmware_headset_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MuseVersion::clear_firmware_headset_version() {
  firmware_headset_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_headset_version();
}
inline const ::std::string& MuseVersion::firmware_headset_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_headset_version)
  return firmware_headset_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_firmware_headset_version(const ::std::string& value) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
inline void MuseVersion::set_firmware_headset_version(const char* value) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
inline void MuseVersion::set_firmware_headset_version(const char* value, size_t size) {
  set_has_firmware_headset_version();
  firmware_headset_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_headset_version)
}
inline ::std::string* MuseVersion::mutable_firmware_headset_version() {
  set_has_firmware_headset_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_headset_version)
  return firmware_headset_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_firmware_headset_version() {
  clear_has_firmware_headset_version();
  return firmware_headset_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_firmware_headset_version(::std::string* firmware_headset_version) {
  if (firmware_headset_version != NULL) {
    set_has_firmware_headset_version();
  } else {
    clear_has_firmware_headset_version();
  }
  firmware_headset_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_headset_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_headset_version)
}

// optional string firmware_type = 3;
inline bool MuseVersion::has_firmware_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MuseVersion::set_has_firmware_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MuseVersion::clear_has_firmware_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MuseVersion::clear_firmware_type() {
  firmware_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_type();
}
inline const ::std::string& MuseVersion::firmware_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_type)
  return firmware_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_firmware_type(const ::std::string& value) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_type)
}
inline void MuseVersion::set_firmware_type(const char* value) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_type)
}
inline void MuseVersion::set_firmware_type(const char* value, size_t size) {
  set_has_firmware_type();
  firmware_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_type)
}
inline ::std::string* MuseVersion::mutable_firmware_type() {
  set_has_firmware_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_type)
  return firmware_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_firmware_type() {
  clear_has_firmware_type();
  return firmware_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_firmware_type(::std::string* firmware_type) {
  if (firmware_type != NULL) {
    set_has_firmware_type();
  } else {
    clear_has_firmware_type();
  }
  firmware_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_type)
}

// optional string firmware_bootloader_version = 4;
inline bool MuseVersion::has_firmware_bootloader_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MuseVersion::set_has_firmware_bootloader_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MuseVersion::clear_has_firmware_bootloader_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MuseVersion::clear_firmware_bootloader_version() {
  firmware_bootloader_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmware_bootloader_version();
}
inline const ::std::string& MuseVersion::firmware_bootloader_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
  return firmware_bootloader_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_firmware_bootloader_version(const ::std::string& value) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
inline void MuseVersion::set_firmware_bootloader_version(const char* value) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
inline void MuseVersion::set_firmware_bootloader_version(const char* value, size_t size) {
  set_has_firmware_bootloader_version();
  firmware_bootloader_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}
inline ::std::string* MuseVersion::mutable_firmware_bootloader_version() {
  set_has_firmware_bootloader_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
  return firmware_bootloader_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_firmware_bootloader_version() {
  clear_has_firmware_bootloader_version();
  return firmware_bootloader_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_firmware_bootloader_version(::std::string* firmware_bootloader_version) {
  if (firmware_bootloader_version != NULL) {
    set_has_firmware_bootloader_version();
  } else {
    clear_has_firmware_bootloader_version();
  }
  firmware_bootloader_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_bootloader_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.firmware_bootloader_version)
}

// optional string build_number = 5;
inline bool MuseVersion::has_build_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MuseVersion::set_has_build_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MuseVersion::clear_has_build_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MuseVersion::clear_build_number() {
  build_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_number();
}
inline const ::std::string& MuseVersion::build_number() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.build_number)
  return build_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_build_number(const ::std::string& value) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.build_number)
}
inline void MuseVersion::set_build_number(const char* value) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.build_number)
}
inline void MuseVersion::set_build_number(const char* value, size_t size) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.build_number)
}
inline ::std::string* MuseVersion::mutable_build_number() {
  set_has_build_number();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.build_number)
  return build_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_build_number() {
  clear_has_build_number();
  return build_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_build_number(::std::string* build_number) {
  if (build_number != NULL) {
    set_has_build_number();
  } else {
    clear_has_build_number();
  }
  build_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_number);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.build_number)
}

// optional string protocol_version = 6;
inline bool MuseVersion::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MuseVersion::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MuseVersion::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MuseVersion::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_version();
}
inline const ::std::string& MuseVersion::protocol_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.protocol_version)
  return protocol_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_protocol_version(const ::std::string& value) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.protocol_version)
}
inline void MuseVersion::set_protocol_version(const char* value) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.protocol_version)
}
inline void MuseVersion::set_protocol_version(const char* value, size_t size) {
  set_has_protocol_version();
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.protocol_version)
}
inline ::std::string* MuseVersion::mutable_protocol_version() {
  set_has_protocol_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_protocol_version() {
  clear_has_protocol_version();
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    set_has_protocol_version();
  } else {
    clear_has_protocol_version();
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.protocol_version)
}

// optional string bsp_version = 7;
inline bool MuseVersion::has_bsp_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MuseVersion::set_has_bsp_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MuseVersion::clear_has_bsp_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MuseVersion::clear_bsp_version() {
  bsp_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bsp_version();
}
inline const ::std::string& MuseVersion::bsp_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseVersion.bsp_version)
  return bsp_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_bsp_version(const ::std::string& value) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseVersion.bsp_version)
}
inline void MuseVersion::set_bsp_version(const char* value) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseVersion.bsp_version)
}
inline void MuseVersion::set_bsp_version(const char* value, size_t size) {
  set_has_bsp_version();
  bsp_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseVersion.bsp_version)
}
inline ::std::string* MuseVersion::mutable_bsp_version() {
  set_has_bsp_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseVersion.bsp_version)
  return bsp_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseVersion::release_bsp_version() {
  clear_has_bsp_version();
  return bsp_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseVersion::set_allocated_bsp_version(::std::string* bsp_version) {
  if (bsp_version != NULL) {
    set_has_bsp_version();
  } else {
    clear_has_bsp_version();
  }
  bsp_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bsp_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseVersion.bsp_version)
}

// -------------------------------------------------------------------

// MuseConfig

// optional string mac_addr = 1;
inline bool MuseConfig::has_mac_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MuseConfig::set_has_mac_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MuseConfig::clear_has_mac_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MuseConfig::clear_mac_addr() {
  mac_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mac_addr();
}
inline const ::std::string& MuseConfig::mac_addr() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.mac_addr)
  return mac_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_mac_addr(const ::std::string& value) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.mac_addr)
}
inline void MuseConfig::set_mac_addr(const char* value) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.mac_addr)
}
inline void MuseConfig::set_mac_addr(const char* value, size_t size) {
  set_has_mac_addr();
  mac_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.mac_addr)
}
inline ::std::string* MuseConfig::mutable_mac_addr() {
  set_has_mac_addr();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.mac_addr)
  return mac_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_mac_addr() {
  clear_has_mac_addr();
  return mac_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_mac_addr(::std::string* mac_addr) {
  if (mac_addr != NULL) {
    set_has_mac_addr();
  } else {
    clear_has_mac_addr();
  }
  mac_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_addr);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.mac_addr)
}

// optional string serial_number = 2;
inline bool MuseConfig::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MuseConfig::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MuseConfig::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MuseConfig::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serial_number();
}
inline const ::std::string& MuseConfig::serial_number() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.serial_number)
  return serial_number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.serial_number)
}
inline void MuseConfig::set_serial_number(const char* value) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.serial_number)
}
inline void MuseConfig::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.serial_number)
}
inline ::std::string* MuseConfig::mutable_serial_number() {
  set_has_serial_number();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_serial_number() {
  clear_has_serial_number();
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    set_has_serial_number();
  } else {
    clear_has_serial_number();
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.serial_number)
}

// optional string preset = 3;
inline bool MuseConfig::has_preset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MuseConfig::set_has_preset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MuseConfig::clear_has_preset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MuseConfig::clear_preset() {
  preset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_preset();
}
inline const ::std::string& MuseConfig::preset() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.preset)
  return preset_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_preset(const ::std::string& value) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.preset)
}
inline void MuseConfig::set_preset(const char* value) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.preset)
}
inline void MuseConfig::set_preset(const char* value, size_t size) {
  set_has_preset();
  preset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.preset)
}
inline ::std::string* MuseConfig::mutable_preset() {
  set_has_preset();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.preset)
  return preset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_preset() {
  clear_has_preset();
  return preset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_preset(::std::string* preset) {
  if (preset != NULL) {
    set_has_preset();
  } else {
    clear_has_preset();
  }
  preset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preset);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.preset)
}

// optional .interaxon.muse_data.MuseConfig.MuseModel model = 4;
inline bool MuseConfig::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MuseConfig::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MuseConfig::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MuseConfig::clear_model() {
  model_ = 1;
  clear_has_model();
}
inline ::interaxon::muse_data::MuseConfig_MuseModel MuseConfig::model() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.model)
  return static_cast< ::interaxon::muse_data::MuseConfig_MuseModel >(model_);
}
inline void MuseConfig::set_model(::interaxon::muse_data::MuseConfig_MuseModel value) {
  assert(::interaxon::muse_data::MuseConfig_MuseModel_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.model)
}

// optional string headband_name = 5;
inline bool MuseConfig::has_headband_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MuseConfig::set_has_headband_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MuseConfig::clear_has_headband_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MuseConfig::clear_headband_name() {
  headband_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headband_name();
}
inline const ::std::string& MuseConfig::headband_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.headband_name)
  return headband_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_headband_name(const ::std::string& value) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.headband_name)
}
inline void MuseConfig::set_headband_name(const char* value) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.headband_name)
}
inline void MuseConfig::set_headband_name(const char* value, size_t size) {
  set_has_headband_name();
  headband_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.headband_name)
}
inline ::std::string* MuseConfig::mutable_headband_name() {
  set_has_headband_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.headband_name)
  return headband_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_headband_name() {
  clear_has_headband_name();
  return headband_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_headband_name(::std::string* headband_name) {
  if (headband_name != NULL) {
    set_has_headband_name();
  } else {
    clear_has_headband_name();
  }
  headband_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headband_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.headband_name)
}

// optional string microcontroller_id = 6;
inline bool MuseConfig::has_microcontroller_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MuseConfig::set_has_microcontroller_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MuseConfig::clear_has_microcontroller_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MuseConfig::clear_microcontroller_id() {
  microcontroller_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_microcontroller_id();
}
inline const ::std::string& MuseConfig::microcontroller_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.microcontroller_id)
  return microcontroller_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_microcontroller_id(const ::std::string& value) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.microcontroller_id)
}
inline void MuseConfig::set_microcontroller_id(const char* value) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.microcontroller_id)
}
inline void MuseConfig::set_microcontroller_id(const char* value, size_t size) {
  set_has_microcontroller_id();
  microcontroller_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.microcontroller_id)
}
inline ::std::string* MuseConfig::mutable_microcontroller_id() {
  set_has_microcontroller_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.microcontroller_id)
  return microcontroller_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_microcontroller_id() {
  clear_has_microcontroller_id();
  return microcontroller_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_microcontroller_id(::std::string* microcontroller_id) {
  if (microcontroller_id != NULL) {
    set_has_microcontroller_id();
  } else {
    clear_has_microcontroller_id();
  }
  microcontroller_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), microcontroller_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.microcontroller_id)
}

// optional bool compression_enabled = 100;
inline bool MuseConfig::has_compression_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MuseConfig::set_has_compression_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MuseConfig::clear_has_compression_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MuseConfig::clear_compression_enabled() {
  compression_enabled_ = false;
  clear_has_compression_enabled();
}
inline bool MuseConfig::compression_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.compression_enabled)
  return compression_enabled_;
}
inline void MuseConfig::set_compression_enabled(bool value) {
  set_has_compression_enabled();
  compression_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.compression_enabled)
}

// optional bool filters_enabled = 201;
inline bool MuseConfig::has_filters_enabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MuseConfig::set_has_filters_enabled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MuseConfig::clear_has_filters_enabled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MuseConfig::clear_filters_enabled() {
  filters_enabled_ = false;
  clear_has_filters_enabled();
}
inline bool MuseConfig::filters_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.filters_enabled)
  return filters_enabled_;
}
inline void MuseConfig::set_filters_enabled(bool value) {
  set_has_filters_enabled();
  filters_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.filters_enabled)
}

// optional uint32 notch_frequency_hz = 202;
inline bool MuseConfig::has_notch_frequency_hz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MuseConfig::set_has_notch_frequency_hz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MuseConfig::clear_has_notch_frequency_hz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MuseConfig::clear_notch_frequency_hz() {
  notch_frequency_hz_ = 0u;
  clear_has_notch_frequency_hz();
}
inline ::google::protobuf::uint32 MuseConfig::notch_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.notch_frequency_hz)
  return notch_frequency_hz_;
}
inline void MuseConfig::set_notch_frequency_hz(::google::protobuf::uint32 value) {
  set_has_notch_frequency_hz();
  notch_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.notch_frequency_hz)
}

// optional uint32 eeg_sample_frequency_hz = 203;
inline bool MuseConfig::has_eeg_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MuseConfig::set_has_eeg_sample_frequency_hz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MuseConfig::clear_has_eeg_sample_frequency_hz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MuseConfig::clear_eeg_sample_frequency_hz() {
  eeg_sample_frequency_hz_ = 0u;
  clear_has_eeg_sample_frequency_hz();
}
inline ::google::protobuf::uint32 MuseConfig::eeg_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_sample_frequency_hz)
  return eeg_sample_frequency_hz_;
}
inline void MuseConfig::set_eeg_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_eeg_sample_frequency_hz();
  eeg_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_sample_frequency_hz)
}

// optional uint32 eeg_output_frequency_hz = 204;
inline bool MuseConfig::has_eeg_output_frequency_hz() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MuseConfig::set_has_eeg_output_frequency_hz() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MuseConfig::clear_has_eeg_output_frequency_hz() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MuseConfig::clear_eeg_output_frequency_hz() {
  eeg_output_frequency_hz_ = 0u;
  clear_has_eeg_output_frequency_hz();
}
inline ::google::protobuf::uint32 MuseConfig::eeg_output_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_output_frequency_hz)
  return eeg_output_frequency_hz_;
}
inline void MuseConfig::set_eeg_output_frequency_hz(::google::protobuf::uint32 value) {
  set_has_eeg_output_frequency_hz();
  eeg_output_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_output_frequency_hz)
}

// optional uint32 eeg_samples_bitwidth = 205;
inline bool MuseConfig::has_eeg_samples_bitwidth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MuseConfig::set_has_eeg_samples_bitwidth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MuseConfig::clear_has_eeg_samples_bitwidth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MuseConfig::clear_eeg_samples_bitwidth() {
  eeg_samples_bitwidth_ = 0u;
  clear_has_eeg_samples_bitwidth();
}
inline ::google::protobuf::uint32 MuseConfig::eeg_samples_bitwidth() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_samples_bitwidth)
  return eeg_samples_bitwidth_;
}
inline void MuseConfig::set_eeg_samples_bitwidth(::google::protobuf::uint32 value) {
  set_has_eeg_samples_bitwidth();
  eeg_samples_bitwidth_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_samples_bitwidth)
}

// optional uint32 eeg_channel_count = 206;
inline bool MuseConfig::has_eeg_channel_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MuseConfig::set_has_eeg_channel_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MuseConfig::clear_has_eeg_channel_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MuseConfig::clear_eeg_channel_count() {
  eeg_channel_count_ = 0u;
  clear_has_eeg_channel_count();
}
inline ::google::protobuf::uint32 MuseConfig::eeg_channel_count() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_channel_count)
  return eeg_channel_count_;
}
inline void MuseConfig::set_eeg_channel_count(::google::protobuf::uint32 value) {
  set_has_eeg_channel_count();
  eeg_channel_count_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_channel_count)
}

// optional string eeg_channel_layout = 207;
inline bool MuseConfig::has_eeg_channel_layout() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MuseConfig::set_has_eeg_channel_layout() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MuseConfig::clear_has_eeg_channel_layout() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MuseConfig::clear_eeg_channel_layout() {
  eeg_channel_layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_eeg_channel_layout();
}
inline const ::std::string& MuseConfig::eeg_channel_layout() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_channel_layout)
  return eeg_channel_layout_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_eeg_channel_layout(const ::std::string& value) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
inline void MuseConfig::set_eeg_channel_layout(const char* value) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
inline void MuseConfig::set_eeg_channel_layout(const char* value, size_t size) {
  set_has_eeg_channel_layout();
  eeg_channel_layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}
inline ::std::string* MuseConfig::mutable_eeg_channel_layout() {
  set_has_eeg_channel_layout();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseConfig.eeg_channel_layout)
  return eeg_channel_layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseConfig::release_eeg_channel_layout() {
  clear_has_eeg_channel_layout();
  return eeg_channel_layout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseConfig::set_allocated_eeg_channel_layout(::std::string* eeg_channel_layout) {
  if (eeg_channel_layout != NULL) {
    set_has_eeg_channel_layout();
  } else {
    clear_has_eeg_channel_layout();
  }
  eeg_channel_layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), eeg_channel_layout);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseConfig.eeg_channel_layout)
}

// optional uint32 eeg_downsample = 208;
inline bool MuseConfig::has_eeg_downsample() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MuseConfig::set_has_eeg_downsample() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MuseConfig::clear_has_eeg_downsample() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MuseConfig::clear_eeg_downsample() {
  eeg_downsample_ = 0u;
  clear_has_eeg_downsample();
}
inline ::google::protobuf::uint32 MuseConfig::eeg_downsample() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_downsample)
  return eeg_downsample_;
}
inline void MuseConfig::set_eeg_downsample(::google::protobuf::uint32 value) {
  set_has_eeg_downsample();
  eeg_downsample_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_downsample)
}

// optional .interaxon.muse_data.EEGUnits eeg_units = 209;
inline bool MuseConfig::has_eeg_units() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MuseConfig::set_has_eeg_units() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MuseConfig::clear_has_eeg_units() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MuseConfig::clear_eeg_units() {
  eeg_units_ = 1;
  clear_has_eeg_units();
}
inline ::interaxon::muse_data::EEGUnits MuseConfig::eeg_units() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_units)
  return static_cast< ::interaxon::muse_data::EEGUnits >(eeg_units_);
}
inline void MuseConfig::set_eeg_units(::interaxon::muse_data::EEGUnits value) {
  assert(::interaxon::muse_data::EEGUnits_IsValid(value));
  set_has_eeg_units();
  eeg_units_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_units)
}

// repeated .interaxon.muse_data.HeadLocations eeg_locations = 210;
inline int MuseConfig::eeg_locations_size() const {
  return eeg_locations_.size();
}
inline void MuseConfig::clear_eeg_locations() {
  eeg_locations_.Clear();
}
inline ::interaxon::muse_data::HeadLocations MuseConfig::eeg_locations(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_locations)
  return static_cast< ::interaxon::muse_data::HeadLocations >(eeg_locations_.Get(index));
}
inline void MuseConfig::set_eeg_locations(int index, ::interaxon::muse_data::HeadLocations value) {
  assert(::interaxon::muse_data::HeadLocations_IsValid(value));
  eeg_locations_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_locations)
}
inline void MuseConfig::add_eeg_locations(::interaxon::muse_data::HeadLocations value) {
  assert(::interaxon::muse_data::HeadLocations_IsValid(value));
  eeg_locations_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseConfig.eeg_locations)
}
inline const ::google::protobuf::RepeatedField<int>&
MuseConfig::eeg_locations() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseConfig.eeg_locations)
  return eeg_locations_;
}
inline ::google::protobuf::RepeatedField<int>*
MuseConfig::mutable_eeg_locations() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseConfig.eeg_locations)
  return &eeg_locations_;
}

// optional float eeg_conversion_factor = 211;
inline bool MuseConfig::has_eeg_conversion_factor() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MuseConfig::set_has_eeg_conversion_factor() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MuseConfig::clear_has_eeg_conversion_factor() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MuseConfig::clear_eeg_conversion_factor() {
  eeg_conversion_factor_ = 0;
  clear_has_eeg_conversion_factor();
}
inline float MuseConfig::eeg_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.eeg_conversion_factor)
  return eeg_conversion_factor_;
}
inline void MuseConfig::set_eeg_conversion_factor(float value) {
  set_has_eeg_conversion_factor();
  eeg_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.eeg_conversion_factor)
}

// optional float afe_gain = 212;
inline bool MuseConfig::has_afe_gain() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MuseConfig::set_has_afe_gain() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MuseConfig::clear_has_afe_gain() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MuseConfig::clear_afe_gain() {
  afe_gain_ = 0;
  clear_has_afe_gain();
}
inline float MuseConfig::afe_gain() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.afe_gain)
  return afe_gain_;
}
inline void MuseConfig::set_afe_gain(float value) {
  set_has_afe_gain();
  afe_gain_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.afe_gain)
}

// optional bool drlref_data_enabled = 300;
inline bool MuseConfig::has_drlref_data_enabled() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MuseConfig::set_has_drlref_data_enabled() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MuseConfig::clear_has_drlref_data_enabled() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MuseConfig::clear_drlref_data_enabled() {
  drlref_data_enabled_ = false;
  clear_has_drlref_data_enabled();
}
inline bool MuseConfig::drlref_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_data_enabled)
  return drlref_data_enabled_;
}
inline void MuseConfig::set_drlref_data_enabled(bool value) {
  set_has_drlref_data_enabled();
  drlref_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_data_enabled)
}

// optional float drlref_conversion_factor = 301;
inline bool MuseConfig::has_drlref_conversion_factor() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MuseConfig::set_has_drlref_conversion_factor() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MuseConfig::clear_has_drlref_conversion_factor() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MuseConfig::clear_drlref_conversion_factor() {
  drlref_conversion_factor_ = 0;
  clear_has_drlref_conversion_factor();
}
inline float MuseConfig::drlref_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_conversion_factor)
  return drlref_conversion_factor_;
}
inline void MuseConfig::set_drlref_conversion_factor(float value) {
  set_has_drlref_conversion_factor();
  drlref_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_conversion_factor)
}

// optional uint32 drlref_sample_frequency_hz = 302;
inline bool MuseConfig::has_drlref_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MuseConfig::set_has_drlref_sample_frequency_hz() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MuseConfig::clear_has_drlref_sample_frequency_hz() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MuseConfig::clear_drlref_sample_frequency_hz() {
  drlref_sample_frequency_hz_ = 0u;
  clear_has_drlref_sample_frequency_hz();
}
inline ::google::protobuf::uint32 MuseConfig::drlref_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.drlref_sample_frequency_hz)
  return drlref_sample_frequency_hz_;
}
inline void MuseConfig::set_drlref_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_drlref_sample_frequency_hz();
  drlref_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.drlref_sample_frequency_hz)
}

// optional bool acc_data_enabled = 400;
inline bool MuseConfig::has_acc_data_enabled() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MuseConfig::set_has_acc_data_enabled() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MuseConfig::clear_has_acc_data_enabled() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MuseConfig::clear_acc_data_enabled() {
  acc_data_enabled_ = false;
  clear_has_acc_data_enabled();
}
inline bool MuseConfig::acc_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_data_enabled)
  return acc_data_enabled_;
}
inline void MuseConfig::set_acc_data_enabled(bool value) {
  set_has_acc_data_enabled();
  acc_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_data_enabled)
}

// optional .interaxon.muse_data.AccelerometerUnits acc_units = 401;
inline bool MuseConfig::has_acc_units() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MuseConfig::set_has_acc_units() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MuseConfig::clear_has_acc_units() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MuseConfig::clear_acc_units() {
  acc_units_ = 1;
  clear_has_acc_units();
}
inline ::interaxon::muse_data::AccelerometerUnits MuseConfig::acc_units() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_units)
  return static_cast< ::interaxon::muse_data::AccelerometerUnits >(acc_units_);
}
inline void MuseConfig::set_acc_units(::interaxon::muse_data::AccelerometerUnits value) {
  assert(::interaxon::muse_data::AccelerometerUnits_IsValid(value));
  set_has_acc_units();
  acc_units_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_units)
}

// optional float acc_conversion_factor = 402;
inline bool MuseConfig::has_acc_conversion_factor() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MuseConfig::set_has_acc_conversion_factor() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MuseConfig::clear_has_acc_conversion_factor() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MuseConfig::clear_acc_conversion_factor() {
  acc_conversion_factor_ = 0;
  clear_has_acc_conversion_factor();
}
inline float MuseConfig::acc_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_conversion_factor)
  return acc_conversion_factor_;
}
inline void MuseConfig::set_acc_conversion_factor(float value) {
  set_has_acc_conversion_factor();
  acc_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_conversion_factor)
}

// optional uint32 acc_sample_frequency_hz = 403;
inline bool MuseConfig::has_acc_sample_frequency_hz() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MuseConfig::set_has_acc_sample_frequency_hz() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MuseConfig::clear_has_acc_sample_frequency_hz() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MuseConfig::clear_acc_sample_frequency_hz() {
  acc_sample_frequency_hz_ = 0u;
  clear_has_acc_sample_frequency_hz();
}
inline ::google::protobuf::uint32 MuseConfig::acc_sample_frequency_hz() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.acc_sample_frequency_hz)
  return acc_sample_frequency_hz_;
}
inline void MuseConfig::set_acc_sample_frequency_hz(::google::protobuf::uint32 value) {
  set_has_acc_sample_frequency_hz();
  acc_sample_frequency_hz_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.acc_sample_frequency_hz)
}

// optional bool battery_data_enabled = 500;
inline bool MuseConfig::has_battery_data_enabled() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MuseConfig::set_has_battery_data_enabled() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MuseConfig::clear_has_battery_data_enabled() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MuseConfig::clear_battery_data_enabled() {
  battery_data_enabled_ = false;
  clear_has_battery_data_enabled();
}
inline bool MuseConfig::battery_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_data_enabled)
  return battery_data_enabled_;
}
inline void MuseConfig::set_battery_data_enabled(bool value) {
  set_has_battery_data_enabled();
  battery_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_data_enabled)
}

// optional uint32 battery_percent_remaining = 501;
inline bool MuseConfig::has_battery_percent_remaining() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MuseConfig::set_has_battery_percent_remaining() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MuseConfig::clear_has_battery_percent_remaining() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MuseConfig::clear_battery_percent_remaining() {
  battery_percent_remaining_ = 0u;
  clear_has_battery_percent_remaining();
}
inline ::google::protobuf::uint32 MuseConfig::battery_percent_remaining() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_percent_remaining)
  return battery_percent_remaining_;
}
inline void MuseConfig::set_battery_percent_remaining(::google::protobuf::uint32 value) {
  set_has_battery_percent_remaining();
  battery_percent_remaining_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_percent_remaining)
}

// optional uint32 battery_millivolts = 502;
inline bool MuseConfig::has_battery_millivolts() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MuseConfig::set_has_battery_millivolts() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MuseConfig::clear_has_battery_millivolts() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MuseConfig::clear_battery_millivolts() {
  battery_millivolts_ = 0u;
  clear_has_battery_millivolts();
}
inline ::google::protobuf::uint32 MuseConfig::battery_millivolts() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.battery_millivolts)
  return battery_millivolts_;
}
inline void MuseConfig::set_battery_millivolts(::google::protobuf::uint32 value) {
  set_has_battery_millivolts();
  battery_millivolts_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.battery_millivolts)
}

// optional bool error_data_enabled = 600;
inline bool MuseConfig::has_error_data_enabled() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MuseConfig::set_has_error_data_enabled() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MuseConfig::clear_has_error_data_enabled() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MuseConfig::clear_error_data_enabled() {
  error_data_enabled_ = false;
  clear_has_error_data_enabled();
}
inline bool MuseConfig::error_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.error_data_enabled)
  return error_data_enabled_;
}
inline void MuseConfig::set_error_data_enabled(bool value) {
  set_has_error_data_enabled();
  error_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.error_data_enabled)
}

// optional bool gyro_data_enabled = 700;
inline bool MuseConfig::has_gyro_data_enabled() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MuseConfig::set_has_gyro_data_enabled() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MuseConfig::clear_has_gyro_data_enabled() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MuseConfig::clear_gyro_data_enabled() {
  gyro_data_enabled_ = false;
  clear_has_gyro_data_enabled();
}
inline bool MuseConfig::gyro_data_enabled() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_data_enabled)
  return gyro_data_enabled_;
}
inline void MuseConfig::set_gyro_data_enabled(bool value) {
  set_has_gyro_data_enabled();
  gyro_data_enabled_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_data_enabled)
}

// optional float gyro_conversion_factor = 702;
inline bool MuseConfig::has_gyro_conversion_factor() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MuseConfig::set_has_gyro_conversion_factor() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MuseConfig::clear_has_gyro_conversion_factor() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MuseConfig::clear_gyro_conversion_factor() {
  gyro_conversion_factor_ = 0;
  clear_has_gyro_conversion_factor();
}
inline float MuseConfig::gyro_conversion_factor() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_conversion_factor)
  return gyro_conversion_factor_;
}
inline void MuseConfig::set_gyro_conversion_factor(float value) {
  set_has_gyro_conversion_factor();
  gyro_conversion_factor_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_conversion_factor)
}

// optional uint32 gyro_sample_frequency = 703;
inline bool MuseConfig::has_gyro_sample_frequency() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MuseConfig::set_has_gyro_sample_frequency() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MuseConfig::clear_has_gyro_sample_frequency() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MuseConfig::clear_gyro_sample_frequency() {
  gyro_sample_frequency_ = 0u;
  clear_has_gyro_sample_frequency();
}
inline ::google::protobuf::uint32 MuseConfig::gyro_sample_frequency() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseConfig.gyro_sample_frequency)
  return gyro_sample_frequency_;
}
inline void MuseConfig::set_gyro_sample_frequency(::google::protobuf::uint32 value) {
  set_has_gyro_sample_frequency();
  gyro_sample_frequency_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseConfig.gyro_sample_frequency)
}

// -------------------------------------------------------------------

// EEG_DroppedSamples

// optional uint32 num = 1;
inline bool EEG_DroppedSamples::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EEG_DroppedSamples::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EEG_DroppedSamples::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EEG_DroppedSamples::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 EEG_DroppedSamples::num() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.EEG_DroppedSamples.num)
  return num_;
}
inline void EEG_DroppedSamples::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.EEG_DroppedSamples.num)
}

// -------------------------------------------------------------------

// ACC_DroppedSamples

// optional uint32 num = 1;
inline bool ACC_DroppedSamples::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACC_DroppedSamples::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACC_DroppedSamples::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACC_DroppedSamples::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ACC_DroppedSamples::num() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ACC_DroppedSamples.num)
  return num_;
}
inline void ACC_DroppedSamples::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ACC_DroppedSamples.num)
}

// -------------------------------------------------------------------

// ComputingDevice

// optional string os_type = 1;
inline bool ComputingDevice::has_os_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputingDevice::set_has_os_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputingDevice::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputingDevice::clear_os_type() {
  os_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_type();
}
inline const ::std::string& ComputingDevice::os_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.os_type)
  return os_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_os_type(const ::std::string& value) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.os_type)
}
inline void ComputingDevice::set_os_type(const char* value) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.os_type)
}
inline void ComputingDevice::set_os_type(const char* value, size_t size) {
  set_has_os_type();
  os_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.os_type)
}
inline ::std::string* ComputingDevice::mutable_os_type() {
  set_has_os_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.os_type)
  return os_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_os_type() {
  clear_has_os_type();
  return os_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_os_type(::std::string* os_type) {
  if (os_type != NULL) {
    set_has_os_type();
  } else {
    clear_has_os_type();
  }
  os_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.os_type)
}

// optional string os_version = 2;
inline bool ComputingDevice::has_os_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputingDevice::set_has_os_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputingDevice::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputingDevice::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_version();
}
inline const ::std::string& ComputingDevice::os_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.os_version)
  return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_os_version(const ::std::string& value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.os_version)
}
inline void ComputingDevice::set_os_version(const char* value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.os_version)
}
inline void ComputingDevice::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.os_version)
}
inline ::std::string* ComputingDevice::mutable_os_version() {
  set_has_os_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_os_version() {
  clear_has_os_version();
  return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    set_has_os_version();
  } else {
    clear_has_os_version();
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.os_version)
}

// optional string hardware_model_name = 3;
inline bool ComputingDevice::has_hardware_model_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputingDevice::set_has_hardware_model_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputingDevice::clear_has_hardware_model_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputingDevice::clear_hardware_model_name() {
  hardware_model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_model_name();
}
inline const ::std::string& ComputingDevice::hardware_model_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.hardware_model_name)
  return hardware_model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_hardware_model_name(const ::std::string& value) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
inline void ComputingDevice::set_hardware_model_name(const char* value) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
inline void ComputingDevice::set_hardware_model_name(const char* value, size_t size) {
  set_has_hardware_model_name();
  hardware_model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.hardware_model_name)
}
inline ::std::string* ComputingDevice::mutable_hardware_model_name() {
  set_has_hardware_model_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.hardware_model_name)
  return hardware_model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_hardware_model_name() {
  clear_has_hardware_model_name();
  return hardware_model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_hardware_model_name(::std::string* hardware_model_name) {
  if (hardware_model_name != NULL) {
    set_has_hardware_model_name();
  } else {
    clear_has_hardware_model_name();
  }
  hardware_model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_model_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.hardware_model_name)
}

// optional string hardware_model_id = 4;
inline bool ComputingDevice::has_hardware_model_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComputingDevice::set_has_hardware_model_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComputingDevice::clear_has_hardware_model_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComputingDevice::clear_hardware_model_id() {
  hardware_model_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hardware_model_id();
}
inline const ::std::string& ComputingDevice::hardware_model_id() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.hardware_model_id)
  return hardware_model_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_hardware_model_id(const ::std::string& value) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
inline void ComputingDevice::set_hardware_model_id(const char* value) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
inline void ComputingDevice::set_hardware_model_id(const char* value, size_t size) {
  set_has_hardware_model_id();
  hardware_model_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.hardware_model_id)
}
inline ::std::string* ComputingDevice::mutable_hardware_model_id() {
  set_has_hardware_model_id();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.hardware_model_id)
  return hardware_model_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_hardware_model_id() {
  clear_has_hardware_model_id();
  return hardware_model_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_hardware_model_id(::std::string* hardware_model_id) {
  if (hardware_model_id != NULL) {
    set_has_hardware_model_id();
  } else {
    clear_has_hardware_model_id();
  }
  hardware_model_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_model_id);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.hardware_model_id)
}

// optional string processor_name = 5;
inline bool ComputingDevice::has_processor_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComputingDevice::set_has_processor_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComputingDevice::clear_has_processor_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComputingDevice::clear_processor_name() {
  processor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor_name();
}
inline const ::std::string& ComputingDevice::processor_name() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.processor_name)
  return processor_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_processor_name(const ::std::string& value) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.processor_name)
}
inline void ComputingDevice::set_processor_name(const char* value) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.processor_name)
}
inline void ComputingDevice::set_processor_name(const char* value, size_t size) {
  set_has_processor_name();
  processor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.processor_name)
}
inline ::std::string* ComputingDevice::mutable_processor_name() {
  set_has_processor_name();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.processor_name)
  return processor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_processor_name() {
  clear_has_processor_name();
  return processor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_processor_name(::std::string* processor_name) {
  if (processor_name != NULL) {
    set_has_processor_name();
  } else {
    clear_has_processor_name();
  }
  processor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor_name);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.processor_name)
}

// optional string processor_speed = 6;
inline bool ComputingDevice::has_processor_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComputingDevice::set_has_processor_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComputingDevice::clear_has_processor_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComputingDevice::clear_processor_speed() {
  processor_speed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor_speed();
}
inline const ::std::string& ComputingDevice::processor_speed() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.processor_speed)
  return processor_speed_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_processor_speed(const ::std::string& value) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.processor_speed)
}
inline void ComputingDevice::set_processor_speed(const char* value) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.processor_speed)
}
inline void ComputingDevice::set_processor_speed(const char* value, size_t size) {
  set_has_processor_speed();
  processor_speed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.processor_speed)
}
inline ::std::string* ComputingDevice::mutable_processor_speed() {
  set_has_processor_speed();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.processor_speed)
  return processor_speed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_processor_speed() {
  clear_has_processor_speed();
  return processor_speed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_processor_speed(::std::string* processor_speed) {
  if (processor_speed != NULL) {
    set_has_processor_speed();
  } else {
    clear_has_processor_speed();
  }
  processor_speed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor_speed);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.processor_speed)
}

// optional uint32 number_of_processors = 7;
inline bool ComputingDevice::has_number_of_processors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComputingDevice::set_has_number_of_processors() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComputingDevice::clear_has_number_of_processors() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComputingDevice::clear_number_of_processors() {
  number_of_processors_ = 0u;
  clear_has_number_of_processors();
}
inline ::google::protobuf::uint32 ComputingDevice::number_of_processors() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.number_of_processors)
  return number_of_processors_;
}
inline void ComputingDevice::set_number_of_processors(::google::protobuf::uint32 value) {
  set_has_number_of_processors();
  number_of_processors_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.number_of_processors)
}

// optional string memory_size = 8;
inline bool ComputingDevice::has_memory_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComputingDevice::set_has_memory_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComputingDevice::clear_has_memory_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComputingDevice::clear_memory_size() {
  memory_size_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory_size();
}
inline const ::std::string& ComputingDevice::memory_size() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.memory_size)
  return memory_size_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_memory_size(const ::std::string& value) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.memory_size)
}
inline void ComputingDevice::set_memory_size(const char* value) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.memory_size)
}
inline void ComputingDevice::set_memory_size(const char* value, size_t size) {
  set_has_memory_size();
  memory_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.memory_size)
}
inline ::std::string* ComputingDevice::mutable_memory_size() {
  set_has_memory_size();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.memory_size)
  return memory_size_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_memory_size() {
  clear_has_memory_size();
  return memory_size_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_memory_size(::std::string* memory_size) {
  if (memory_size != NULL) {
    set_has_memory_size();
  } else {
    clear_has_memory_size();
  }
  memory_size_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory_size);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.memory_size)
}

// optional string bluetooth_version = 9;
inline bool ComputingDevice::has_bluetooth_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComputingDevice::set_has_bluetooth_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComputingDevice::clear_has_bluetooth_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComputingDevice::clear_bluetooth_version() {
  bluetooth_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_version();
}
inline const ::std::string& ComputingDevice::bluetooth_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.bluetooth_version)
  return bluetooth_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_bluetooth_version(const ::std::string& value) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
inline void ComputingDevice::set_bluetooth_version(const char* value) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
inline void ComputingDevice::set_bluetooth_version(const char* value, size_t size) {
  set_has_bluetooth_version();
  bluetooth_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.bluetooth_version)
}
inline ::std::string* ComputingDevice::mutable_bluetooth_version() {
  set_has_bluetooth_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.bluetooth_version)
  return bluetooth_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_bluetooth_version() {
  clear_has_bluetooth_version();
  return bluetooth_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_bluetooth_version(::std::string* bluetooth_version) {
  if (bluetooth_version != NULL) {
    set_has_bluetooth_version();
  } else {
    clear_has_bluetooth_version();
  }
  bluetooth_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.bluetooth_version)
}

// optional string time_zone = 10;
inline bool ComputingDevice::has_time_zone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ComputingDevice::set_has_time_zone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ComputingDevice::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ComputingDevice::clear_time_zone() {
  time_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_time_zone();
}
inline const ::std::string& ComputingDevice::time_zone() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.time_zone)
  return time_zone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_time_zone(const ::std::string& value) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.time_zone)
}
inline void ComputingDevice::set_time_zone(const char* value) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.ComputingDevice.time_zone)
}
inline void ComputingDevice::set_time_zone(const char* value, size_t size) {
  set_has_time_zone();
  time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.ComputingDevice.time_zone)
}
inline ::std::string* ComputingDevice::mutable_time_zone() {
  set_has_time_zone();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.ComputingDevice.time_zone)
  return time_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputingDevice::release_time_zone() {
  clear_has_time_zone();
  return time_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputingDevice::set_allocated_time_zone(::std::string* time_zone) {
  if (time_zone != NULL) {
    set_has_time_zone();
  } else {
    clear_has_time_zone();
  }
  time_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time_zone);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.ComputingDevice.time_zone)
}

// optional sint32 time_zone_offset_seconds = 11;
inline bool ComputingDevice::has_time_zone_offset_seconds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ComputingDevice::set_has_time_zone_offset_seconds() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ComputingDevice::clear_has_time_zone_offset_seconds() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ComputingDevice::clear_time_zone_offset_seconds() {
  time_zone_offset_seconds_ = 0;
  clear_has_time_zone_offset_seconds();
}
inline ::google::protobuf::int32 ComputingDevice::time_zone_offset_seconds() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.ComputingDevice.time_zone_offset_seconds)
  return time_zone_offset_seconds_;
}
inline void ComputingDevice::set_time_zone_offset_seconds(::google::protobuf::int32 value) {
  set_has_time_zone_offset_seconds();
  time_zone_offset_seconds_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.ComputingDevice.time_zone_offset_seconds)
}

// -------------------------------------------------------------------

// DSP

// optional string type = 1;
inline bool DSP::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DSP::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DSP::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DSP::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DSP::type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSP::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.type)
}
inline void DSP::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.DSP.type)
}
inline void DSP::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.DSP.type)
}
inline ::std::string* DSP::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.DSP.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSP::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSP::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.DSP.type)
}

// repeated float float_array = 2;
inline int DSP::float_array_size() const {
  return float_array_.size();
}
inline void DSP::clear_float_array() {
  float_array_.Clear();
}
inline float DSP::float_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.float_array)
  return float_array_.Get(index);
}
inline void DSP::set_float_array(int index, float value) {
  float_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.float_array)
}
inline void DSP::add_float_array(float value) {
  float_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.DSP.float_array)
}
inline const ::google::protobuf::RepeatedField< float >&
DSP::float_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.DSP.float_array)
  return float_array_;
}
inline ::google::protobuf::RepeatedField< float >*
DSP::mutable_float_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.DSP.float_array)
  return &float_array_;
}

// repeated uint32 int_array = 3;
inline int DSP::int_array_size() const {
  return int_array_.size();
}
inline void DSP::clear_int_array() {
  int_array_.Clear();
}
inline ::google::protobuf::uint32 DSP::int_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.int_array)
  return int_array_.Get(index);
}
inline void DSP::set_int_array(int index, ::google::protobuf::uint32 value) {
  int_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.int_array)
}
inline void DSP::add_int_array(::google::protobuf::uint32 value) {
  int_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.DSP.int_array)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DSP::int_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.DSP.int_array)
  return int_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DSP::mutable_int_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.DSP.int_array)
  return &int_array_;
}

// optional string version = 4;
inline bool DSP::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DSP::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DSP::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DSP::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& DSP::version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.DSP.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSP::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.DSP.version)
}
inline void DSP::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.DSP.version)
}
inline void DSP::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.DSP.version)
}
inline ::std::string* DSP::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.DSP.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSP::release_version() {
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSP::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.DSP.version)
}

// -------------------------------------------------------------------

// MuseElement

// optional .interaxon.muse_data.MuseElementType type = 1;
inline bool MuseElement::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MuseElement::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MuseElement::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MuseElement::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::interaxon::muse_data::MuseElementType MuseElement::type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.type)
  return static_cast< ::interaxon::muse_data::MuseElementType >(type_);
}
inline void MuseElement::set_type(::interaxon::muse_data::MuseElementType value) {
  assert(::interaxon::muse_data::MuseElementType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.type)
}

// optional string string_type = 2;
inline bool MuseElement::has_string_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MuseElement::set_has_string_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MuseElement::clear_has_string_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MuseElement::clear_string_type() {
  string_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_string_type();
}
inline const ::std::string& MuseElement::string_type() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.string_type)
  return string_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseElement::set_string_type(const ::std::string& value) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.string_type)
}
inline void MuseElement::set_string_type(const char* value) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:interaxon.muse_data.MuseElement.string_type)
}
inline void MuseElement::set_string_type(const char* value, size_t size) {
  set_has_string_type();
  string_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:interaxon.muse_data.MuseElement.string_type)
}
inline ::std::string* MuseElement::mutable_string_type() {
  set_has_string_type();
  // @@protoc_insertion_point(field_mutable:interaxon.muse_data.MuseElement.string_type)
  return string_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MuseElement::release_string_type() {
  clear_has_string_type();
  return string_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MuseElement::set_allocated_string_type(::std::string* string_type) {
  if (string_type != NULL) {
    set_has_string_type();
  } else {
    clear_has_string_type();
  }
  string_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string_type);
  // @@protoc_insertion_point(field_set_allocated:interaxon.muse_data.MuseElement.string_type)
}

// optional uint32 algorithm_version = 3;
inline bool MuseElement::has_algorithm_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MuseElement::set_has_algorithm_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MuseElement::clear_has_algorithm_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MuseElement::clear_algorithm_version() {
  algorithm_version_ = 0u;
  clear_has_algorithm_version();
}
inline ::google::protobuf::uint32 MuseElement::algorithm_version() const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.algorithm_version)
  return algorithm_version_;
}
inline void MuseElement::set_algorithm_version(::google::protobuf::uint32 value) {
  set_has_algorithm_version();
  algorithm_version_ = value;
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.algorithm_version)
}

// repeated double real_array = 4;
inline int MuseElement::real_array_size() const {
  return real_array_.size();
}
inline void MuseElement::clear_real_array() {
  real_array_.Clear();
}
inline double MuseElement::real_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.real_array)
  return real_array_.Get(index);
}
inline void MuseElement::set_real_array(int index, double value) {
  real_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.real_array)
}
inline void MuseElement::add_real_array(double value) {
  real_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseElement.real_array)
}
inline const ::google::protobuf::RepeatedField< double >&
MuseElement::real_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseElement.real_array)
  return real_array_;
}
inline ::google::protobuf::RepeatedField< double >*
MuseElement::mutable_real_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseElement.real_array)
  return &real_array_;
}

// repeated uint32 integer_array = 5;
inline int MuseElement::integer_array_size() const {
  return integer_array_.size();
}
inline void MuseElement::clear_integer_array() {
  integer_array_.Clear();
}
inline ::google::protobuf::uint32 MuseElement::integer_array(int index) const {
  // @@protoc_insertion_point(field_get:interaxon.muse_data.MuseElement.integer_array)
  return integer_array_.Get(index);
}
inline void MuseElement::set_integer_array(int index, ::google::protobuf::uint32 value) {
  integer_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:interaxon.muse_data.MuseElement.integer_array)
}
inline void MuseElement::add_integer_array(::google::protobuf::uint32 value) {
  integer_array_.Add(value);
  // @@protoc_insertion_point(field_add:interaxon.muse_data.MuseElement.integer_array)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MuseElement::integer_array() const {
  // @@protoc_insertion_point(field_list:interaxon.muse_data.MuseElement.integer_array)
  return integer_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MuseElement::mutable_integer_array() {
  // @@protoc_insertion_point(field_mutable_list:interaxon.muse_data.MuseElement.integer_array)
  return &integer_array_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace muse_data
}  // namespace interaxon

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::interaxon::muse_data::MuseData_Datatype> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::Annotation_Format> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::MuseConfig_MuseModel> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::HeadLocations> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::EEGUnits> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::AccelerometerUnits> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::interaxon::muse_data::MuseElementType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Muse_5fv2_2eproto__INCLUDED
